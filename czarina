#!/usr/bin/env python3
"""
Czarina - Multi-Agent Orchestration CLI
Simple interface for managing multi-agent orchestration projects

Version: 0.6.2

Usage:
    czarina analyze <plan-file>                  - Analyze plan and suggest orchestration
    czarina analyze <plan-file> --interactive    - Interactive mode (works with any AI agent!)
    czarina analyze <plan-file> --init           - Analyze and initialize project
    czarina analyze <plan-file> --output file    - Save analysis to file
    czarina init [project-name]                  - Initialize orchestration in current dir
    czarina init --plan <plan.md>                - Initialize from implementation plan (launches agent)
    czarina init --from-config <config.json>     - Initialize from pre-made config file
    czarina init --from-config <file> --force    - Re-initialize (replaces existing)
    czarina launch                               - Launch workers (searches current dir and parents)
    czarina status                               - Show project status
    czarina dashboard                            - Live monitoring dashboard
    czarina phase close [project]                - Close current phase, keep project for next phase
    czarina phase list [project]                 - List all phases
    czarina closeout [project]                   - Stop all workers and clean up completely
    czarina daemon start [project]               - Start autonomous daemon
    czarina daemon stop [project]                - Stop daemon
    czarina daemon logs [project]                - Show daemon logs
    czarina daemon status [project]              - Check daemon status
    czarina hopper add <file.md>                 - Add enhancement to project hopper
    czarina hopper list [project|phase]          - List hopper items
    czarina hopper pull <file> --to-phase        - Pull item into phase
    czarina hopper defer <file>                  - Defer item to backlog
    czarina hopper assign <worker> <file>        - Assign to worker
    czarina deps check [worker-id]               - Check dependency status for workers
    czarina deps validate <worker-id>            - Validate dependencies ready for worker
    czarina memory init                          - Initialize memory system
    czarina memory query "<text>"                - Search memories for relevant context
    czarina memory rebuild                       - Rebuild vector index from memories.md
    czarina memory extract                       - Extract session learnings to memory
    czarina memory core                          - Show architectural core
    czarina patterns update                      - Update pattern library
    czarina patterns version                     - Show pattern version
    czarina patterns pending                     - List patterns ready to contribute
    czarina patterns contribute                  - Show contribution guide
    czarina version                              - Show version information
"""

CZARINA_VERSION = "0.6.2"

import sys
import subprocess
import json
import os
from pathlib import Path
from datetime import datetime

# Add czarina-core to path for imports
# Resolve symlinks to find the actual repository location
sys.path.insert(0, str(Path(__file__).resolve().parent / "czarina-core"))


def get_orchestrator_dir():
    """Get the orchestrator root directory"""
    return Path(__file__).resolve().parent


def find_czarina_dir(start_path=None):
    """
    Find .czarina/ directory by searching up from start_path
    Returns (czarina_dir, project_root) or (None, None)
    """
    if start_path is None:
        start_path = Path.cwd()
    else:
        start_path = Path(start_path).resolve()

    current = start_path
    while current != current.parent:
        czarina_dir = current / ".czarina"
        if czarina_dir.exists() and czarina_dir.is_dir():
            return czarina_dir, current
        current = current.parent

    return None, None


# find_project_by_name() removed - czarina is purely local to each repo
# Use current directory or parent directories only


def get_project_context(project_name=None):
    """
    Get project context (czarina_dir and project_root)

    Searches current directory and parent directories for .czarina/
    """
    if project_name:
        print(f"‚ö†Ô∏è  Project name argument is deprecated")
        print(f"   Czarina is local to each repo - cd to the project directory instead")
        print()

    # Look for .czarina/ in current directory or parents
    czarina_dir, project_root = find_czarina_dir()
    if czarina_dir:
        return czarina_dir, project_root

    print("‚ùå No Czarina project found")
    print("üí° Run 'czarina init --plan <plan.md>' to create orchestration")
    print("üí° Or cd to a directory with .czarina/ configuration")
    sys.exit(1)


def _create_czarina_readme(czarina_dir, config):
    """Helper to create README.md for .czarina directory"""
    readme = czarina_dir / "README.md"
    project_name = config["project"]["name"]
    workers = config["workers"]
    worker_list = "\n".join([f"- **{w['id']}**: {w.get('description', 'Worker')}"
                             for w in workers])

    with open(readme, "w") as f:
        f.write(f"""# Czarina Orchestration - {project_name}

## Quick Start

### For Workers

**Claude Code / Desktop:**
```bash
./.czarina/.worker-init <worker-id>
```

**Claude Code Web (auto-discovery):**
Just say: "You are <worker-id>"

### For Orchestrators

**Launch all workers:**
```bash
czarina launch
```

**Start daemon (auto-approval):**
```bash
czarina daemon start
```

**Check status:**
```bash
czarina status
```

## Configuration

Edit `.czarina/config.json` to:
- Add/remove workers
- Configure agent types
- Set daemon behavior

Edit `.czarina/workers/*.md` to define worker roles and tasks.

## Workers

{worker_list}

## Project

**Repository:** {config['project']['repository']}
**Orchestration:** .czarina/

Created: {datetime.now().strftime('%Y-%m-%d')}
""")


def cmd_init_from_config(config_file_path, current_dir, czarina_dir):
    """Initialize from a pre-made configuration file"""
    config_path = Path(config_file_path)

    if not config_path.exists():
        print(f"‚ùå Config file not found: {config_file_path}")
        sys.exit(1)

    print(f"üìÑ Loading configuration from: {config_file_path}")
    print()

    # Load the user's config
    with open(config_path) as f:
        user_config = json.load(f)

    # Create .czarina/ structure (may already exist from phase close)
    czarina_dir.mkdir(exist_ok=True)
    (czarina_dir / "workers").mkdir(exist_ok=True)
    (czarina_dir / "status").mkdir(exist_ok=True)

    # Convert user format to czarina format
    workers_dict = user_config.get("workers", {})
    workers_list = []

    for worker_id, worker_data in workers_dict.items():
        workers_list.append({
            "id": worker_id,
            "agent": worker_data.get("agent", "aider"),
            "branch": worker_data.get("branch", f"feat/{worker_id}"),
            "description": worker_data.get("name", worker_data.get("role", f"Worker {worker_id}"))
        })

    # Build czarina config
    czarina_config = {
        "project": {
            "name": user_config.get("project", current_dir.name),
            "slug": user_config.get("project", current_dir.name).lower().replace(" ", "-"),
            "repository": str(current_dir),
            "orchestration_dir": ".czarina",
            "version": user_config.get("version", "1.0.0"),
            "phase": user_config.get("phase", "default"),
            "description": user_config.get("description", "")
        },
        "workers": workers_list,
        "daemon": user_config.get("daemon", {
            "enabled": True,
            "auto_approve": ["read", "write", "commit"]
        })
    }

    # Save czarina config
    config_file = czarina_dir / "config.json"
    with open(config_file, 'w') as f:
        json.dump(czarina_config, f, indent=2)
    print(f"‚úÖ Created: .czarina/config.json")

    # Generate worker prompts from user config
    for worker_id, worker_data in workers_dict.items():
        worker_file = czarina_dir / "workers" / f"{worker_id}.md"

        # Build worker prompt from user's data
        tasks_section = ""
        if "tasks" in worker_data:
            tasks_section = "\n## Tasks\n\n" + "\n".join([f"- {task}" for task in worker_data["tasks"]])

        files_section = ""
        if "files" in worker_data:
            files_section = "\n## Files\n\n" + "\n".join([f"- `{f}`" for f in worker_data["files"]])

        criteria_section = ""
        if "completion_criteria" in worker_data:
            criteria_section = "\n## Completion Criteria\n\n" + "\n".join([f"- [ ] {c}" for c in worker_data["completion_criteria"]])

        budget = worker_data.get("budget", {})
        token_budget = budget.get("tokens_projected", budget.get("tokens_max", "N/A"))

        # Format token budget with commas only if it's a number
        if isinstance(token_budget, (int, float)):
            token_budget_str = f"{token_budget:,}"
        else:
            token_budget_str = str(token_budget)

        token_max = budget.get('tokens_max', 'N/A')
        if isinstance(token_max, (int, float)):
            token_max_str = f"{token_max:,}"
        else:
            token_max_str = str(token_max)

        with open(worker_file, 'w') as f:
            f.write(f"""# {worker_data.get('name', worker_id)}

## Role
{worker_data.get('role', 'Worker for this project')}

## Branch
{worker_data.get('branch', f'feat/{worker_id}')}

## Token Budget
{token_budget_str} tokens (max: {token_max_str})
{tasks_section}{files_section}{criteria_section}

## Dependencies
{', '.join(worker_data.get('dependencies', [])) or 'None'}

## Git Workflow
When your work is complete:
1. Commit your changes
2. Push to your branch
3. Create a PR to main
4. Update token metrics in status

## Pattern Library
Review before starting:
- czarina-core/patterns/ERROR_RECOVERY_PATTERNS.md
- czarina-core/patterns/CZARINA_PATTERNS.md
""")
        print(f"‚úÖ Created: .czarina/workers/{worker_id}.md")

    # Create CZAR.md
    worker_list = "\n".join([f"- **{w['id']}**: {w.get('description', 'Worker')}"
                             for w in workers_list])
    czar_file = czarina_dir / "workers" / "CZAR.md"
    with open(czar_file, 'w') as f:
        f.write(f"""# Czar - Orchestration Coordinator

## Your Role

You are the **Czar** - the orchestration coordinator for this multi-agent project.

**Project:** {czarina_config['project']['name']}
**Version:** {czarina_config['project']['version']}
**Phase:** {czarina_config['project']['phase']}
**Workers:** {len(workers_list)}

{czarina_config['project']['description']}

## Workers

{worker_list}

## Quick Commands

### Tmux Navigation
- Switch windows: Ctrl+b <number>
- List windows: Ctrl+b w
- Detach: Ctrl+b d

### Git Operations
- Check worktrees: `git worktree list`
- Check branches: `git branch -a`

### Czarina Commands
- Status: `czarina status`
- Dashboard: `czarina dashboard`
- Phase close: `czarina phase close`

## Responsibilities

1. Monitor worker progress
2. Coordinate dependencies
3. Review PRs and manage merges
4. Track project health

‚úÖ Ready to orchestrate!
""")
    print(f"‚úÖ Created: .czarina/workers/CZAR.md")

    # Create README
    _create_czarina_readme(czarina_dir, czarina_config)
    print(f"‚úÖ Created: .czarina/README.md")

    print()
    print("üéâ Czarina initialized successfully!")
    print()
    print(f"üìÅ Created in: {current_dir}")
    print(f"üìã Project: {czarina_config['project']['name']} ({czarina_config['project']['slug']})")
    print()
    print("üìù Next steps:")
    print("  1. Review and edit .czarina/workers/*.md files")
    print("  2. czarina launch")


def cmd_init(project_name=None, from_config=None, from_plan=None, force=False):
    """Initialize Czarina orchestration in current directory"""
    current_dir = Path.cwd()

    # Check if already initialized
    czarina_dir = current_dir / ".czarina"
    config_file = czarina_dir / "config.json"
    workers_dir = czarina_dir / "workers"

    if czarina_dir.exists() and config_file.exists():
        # Check if this is an active project or a phase-closed structure
        import shutil

        # If workers directory is empty or doesn't exist, assume phase was closed
        workers_exist = workers_dir.exists() and any(workers_dir.iterdir())

        if workers_exist and not force:
            print(f"‚ùå Czarina already initialized in {current_dir}")
            print(f"   .czarina/ directory exists with active workers")
            print()
            print("üí° Options:")
            print("   1. Close current phase first: czarina phase close")
            print("   2. Force re-initialize: czarina init --from-config <file> --force")
            sys.exit(1)

        if force or not workers_exist:
            if force:
                print(f"‚ö†Ô∏è  Reinitializing (--force): {current_dir}")
            else:
                print(f"üì¶ Initializing new phase in existing project")

            print(f"   Archiving previous phase...")

            # Archive existing config/workers to phases
            phases_dir = czarina_dir / "phases"
            phases_dir.mkdir(exist_ok=True)
            backup_name = f"phase-{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}-reInit"
            backup_dir = phases_dir / backup_name
            backup_dir.mkdir()

            if config_file.exists():
                shutil.copy(config_file, backup_dir / "config.json")
            if workers_dir.exists() and any(workers_dir.iterdir()):
                shutil.copytree(workers_dir, backup_dir / "workers")

            print(f"   ‚úÖ Backed up to: .czarina/phases/{backup_name}")

            # Remove old config and workers (keep phases, archive, status dirs)
            if config_file.exists():
                config_file.unlink()
            if workers_dir.exists():
                shutil.rmtree(workers_dir)

    # Handle --from-plan (launch Claude Code to create config from plan)
    if from_plan:
        plan_path = Path(from_plan).resolve()
        if not plan_path.exists():
            print(f"‚ùå Plan file not found: {from_plan}")
            sys.exit(1)

        print("üîç Initializing from plan file")
        print("=" * 60)
        print()
        print(f"üìÑ Plan: {from_plan}")
        print()

        # Create .czarina directory if it doesn't exist
        if not czarina_dir.exists():
            print("üìÅ Creating .czarina directory structure...")
            czarina_dir.mkdir()
            (czarina_dir / "workers").mkdir()
            print("   ‚úÖ Created .czarina/")
            print("   ‚úÖ Created .czarina/workers/")
            print()

        # Build Claude Code prompt
        prompt = f"""Read the implementation plan at {plan_path} and help me set up a czarina orchestration.

Please:
1. Analyze the plan and identify the key workers needed
2. Create a config.json file in .czarina/ with the project structure
3. Create worker definition markdown files in .czarina/workers/ for each worker
4. Follow the czarina configuration format

The config.json should include:
- project metadata (name, slug, version, phase, omnibus_branch)
- orchestration mode (local or github)
- worker definitions (id, agent, branch, dependencies, role)
- any special configuration (hopper, daemon settings, etc.)

CRITICAL - Branch Naming Convention:
- Worker branches MUST follow the pattern: cz<phase>/feat/<worker-id>
- Omnibus branch MUST follow the pattern: cz<phase>/release/v<version>
- For example, if phase is "1" or "implementation":
  * Worker branch: cz1/feat/logging OR czimplementation/feat/logging
  * Omnibus branch: cz1/release/v0.6.0 OR czimplementation/release/v0.6.0
- DO NOT use the old "worker/" prefix - it will fail validation!

Each worker markdown file should include:
- Mission and deliverables
- Detailed task breakdown
- References to relevant documentation

Let's get started!"""

        print("üöÄ Launching Claude Code to help with orchestration setup...")
        print()
        print("üí° Claude will help you create:")
        print("   - .czarina/config.json")
        print("   - .czarina/workers/*.md files")
        print()

        # Launch Claude Code
        import subprocess
        import shutil

        if not shutil.which("claude"):
            print()
            print("‚ùå Claude Code CLI not found!")
            print("   Please install: https://code.claude.com")
            print()
            print("üí° Alternatively, manually create:")
            print("   - .czarina/config.json")
            print("   - .czarina/workers/*.md files")
            print()
            sys.exit(1)

        print(f"   Using: Claude Code")
        print()

        try:
            subprocess.run(["claude", prompt], check=True)

            print()
            print("=" * 60)
            print()
            print("‚úÖ Czarina initialized from plan!")
            print()
            print("üìã Next steps:")
            print("   1. Verify .czarina/config.json was created")
            print("   2. Review .czarina/workers/*.md files")
            print("   3. Launch the orchestration:")
            print("      czarina launch")
            print()
            return

        except Exception as e:
            print()
            print(f"‚ùå Failed to launch Claude Code: {e}")
            print()
            sys.exit(1)

    # Handle --from-config (user provides pre-made config)
    if from_config:
        return cmd_init_from_config(from_config, current_dir, czarina_dir)

    # Detect project name from directory or use provided
    if not project_name:
        project_name = current_dir.name

    # Create slug: lowercase, replace spaces/underscores with single dash, remove special chars
    import re
    slug = project_name.lower()
    slug = re.sub(r'[_\s]+', '-', slug)  # Replace spaces/underscores with single dash
    slug = re.sub(r'[^a-z0-9\-]', '', slug)  # Remove non-alphanumeric except dash
    slug = re.sub(r'-+', '-', slug)  # Collapse multiple dashes
    slug = slug.strip('-')  # Remove leading/trailing dashes

    # Create .czarina/ structure
    czarina_dir.mkdir()
    (czarina_dir / "workers").mkdir()
    (czarina_dir / "status").mkdir()

    # Create config.json
    config = {
        "project": {
            "name": project_name,
            "slug": slug,
            "repository": str(current_dir),
            "orchestration_dir": ".czarina"
        },
        "workers": [
            {
                "id": "worker1",
                "agent": "aider",
                "branch": f"feat/{slug}-worker1",
                "description": "Worker 1"
            }
        ],
        "daemon": {
            "enabled": True,
            "auto_approve": ["read", "write", "commit"]
        }
    }

    config_file = czarina_dir / "config.json"
    with open(config_file, "w") as f:
        json.dump(config, f, indent=2)

    # Create example worker prompt
    worker_file = czarina_dir / "workers" / "worker1.md"
    with open(worker_file, "w") as f:
        f.write(f"""# Worker 1 - {project_name}

## Role
[Describe this worker's role]

## Responsibilities
- [Responsibility 1]
- [Responsibility 2]

## Files
- [Files this worker should work on]

## Git Workflow
Branch: feat/{slug}-worker1

When your work is complete:
1. Commit your changes
2. Push to your branch
3. Create a PR to main
4. Wait for review

## Pattern Library
Before starting, review:
- czarina-core/patterns/ERROR_RECOVERY_PATTERNS.md
- czarina-core/patterns/CZARINA_PATTERNS.md
""")

    # Create .worker-init script for auto-discovery
    worker_init = czarina_dir / ".worker-init"
    orchestrator_dir = get_orchestrator_dir()
    with open(worker_init, "w") as f:
        f.write(f"""#!/bin/bash
# Czarina Worker Auto-Init
# This script helps workers discover their role and setup

CZARINA_DIR="$(cd "$(dirname "${{BASH_SOURCE[0]}}")" && pwd)"
CONFIG_FILE="$CZARINA_DIR/config.json"

if [ ! -f "$CONFIG_FILE" ]; then
    echo "‚ùå Config file not found: $CONFIG_FILE"
    exit 1
fi

# Show available workers
echo "üìã Available workers:"
jq -r '.workers[] | "  ‚Ä¢ \\(.id) - \\(.description)"' "$CONFIG_FILE"
echo ""

# If worker ID provided, load it
if [ -n "$1" ]; then
    WORKER_ID="$1"
    WORKER_FILE="$CZARINA_DIR/workers/$WORKER_ID.md"

    if [ -f "$WORKER_FILE" ]; then
        echo "‚úÖ Loading worker: $WORKER_ID"
        cat "$WORKER_FILE"
    else
        echo "‚ùå Worker file not found: $WORKER_FILE"
        exit 1
    fi
else
    echo "üí° Usage: ./.czarina/.worker-init <worker-id>"
fi
""")
    worker_init.chmod(0o755)

    # Create README
    readme = czarina_dir / "README.md"
    with open(readme, "w") as f:
        f.write(f"""# Czarina Orchestration - {project_name}

## Quick Start

### For Workers

**Claude Code / Desktop:**
```bash
./.czarina/.worker-init worker1
```

**Claude Code Web (auto-discovery):**
Just say: "You are worker1"

### For Orchestrators

**Launch all workers:**
```bash
czarina launch
```

**Start daemon (auto-approval):**
```bash
czarina daemon start
```

**Check status:**
```bash
czarina status
```

## Configuration

Edit `.czarina/config.json` to:
- Add/remove workers
- Configure agent types
- Set daemon behavior

Edit `.czarina/workers/*.md` to define worker roles and tasks.

## Workers

{chr(10).join(f"- **{w['id']}**: {w['description']}" for w in config['workers'])}

## Project

**Repository:** {current_dir}
**Orchestration:** .czarina/

Created: {datetime.now().strftime('%Y-%m-%d')}
""")

    # Update .gitignore
    gitignore = current_dir / ".gitignore"
    gitignore_content = ""
    if gitignore.exists():
        gitignore_content = gitignore.read_text()

    if ".czarina/status/" not in gitignore_content:
        with open(gitignore, "a") as f:
            if gitignore_content and not gitignore_content.endswith("\n"):
                f.write("\n")
            f.write("\n# Czarina orchestration\n")
            f.write(".czarina/status/\n")
            f.write(".czarina/worktrees/\n")

    # Copy branch loader script
    import shutil
    loader_template = orchestrator_dir / "czarina-core" / "templates" / "embedded-orchestration" / "load-worker-by-branch.sh"
    loader_dest = czarina_dir / "load-worker-by-branch.sh"
    if loader_template.exists():
        shutil.copy(loader_template, loader_dest)
        loader_dest.chmod(0o755)

    # Initialize git branches if this is a git repo
    if (current_dir / ".git").exists():
        print("\nüåø Initializing git branches...")
        init_branches_script = orchestrator_dir / "czarina-core" / "init-embedded-branches.sh"
        if init_branches_script.exists():
            result = subprocess.run(
                ["bash", str(init_branches_script), str(current_dir)],
                input="n\n",  # Auto-answer "no" to pull prompt
                text=True,
                capture_output=True
            )
            if result.returncode == 0:
                print("‚úÖ Git branches initialized")

    print("\n‚úÖ Czarina initialized successfully!")
    print(f"\nüìÅ Created in: {current_dir}")
    print(f"üìã Project: {project_name} ({slug})")
    print(f"\nüìù Next steps:")
    print(f"  1. Edit .czarina/config.json - configure workers")
    print(f"  2. Edit .czarina/workers/*.md - define worker roles")
    print(f"  3. (Optional) Setup .claude/settings.local.json SessionStart hook")
    print(f"     See: {orchestrator_dir}/docs/BRANCH_BASED_WORKER_LOADING.md")
    print(f"  4. git add .czarina/")
    print(f"  5. git commit -m 'Add Czarina orchestration'")
    print(f"  6. czarina launch  (will auto-create branches if needed)")
    print(f"\nüí° Read more: {orchestrator_dir}/docs/BRANCH_BASED_WORKER_LOADING.md")


# cmd_list() removed - czarina is purely local to each repo
# No global project registry needed


def cmd_launch(project_name=None):
    """Launch workers for project"""
    czarina_dir, project_root = get_project_context(project_name)

    # Load config
    config_file = czarina_dir / "config.json"
    with open(config_file) as f:
        config = json.load(f)

    project_slug = config["project"]["slug"]
    workers = config["workers"]

    print(f"üöÄ Launching: {config['project']['name']}")
    print(f"   Workers: {len(workers)}")
    print(f"   Project: {project_root}")
    print()

    # Check if git repo exists
    orchestrator_dir = get_orchestrator_dir()
    if not (project_root / ".git").exists():
        print("‚ö†Ô∏è  This directory is not a git repository")
        print()
        response = input("Would you like to initialize a git repo? (Y/n): ")
        if response.lower() not in ['n', 'no']:
            print("üì¶ Initializing git repository...")
            subprocess.run(["git", "-C", str(project_root), "init"], check=True)
            subprocess.run(["git", "-C", str(project_root), "add", ".czarina"], check=True)
            subprocess.run(["git", "-C", str(project_root), "commit", "-m", "chore: Initialize czarina orchestration"], check=True)
            print("‚úÖ Git repository initialized")
            print()
        else:
            print("‚ö†Ô∏è  Continuing without git - some features may not work")
            print()

    # Check if git branches exist, initialize if needed
    if (project_root / ".git").exists():
        # Check if any worker branches are missing
        branches_missing = False
        for worker in workers:
            branch = worker.get("branch", "")
            if branch:
                result = subprocess.run(
                    ["git", "-C", str(project_root), "show-ref", "--verify", "--quiet", f"refs/heads/{branch}"],
                    capture_output=True
                )
                if result.returncode != 0:
                    branches_missing = True
                    break

        if branches_missing:
            print("üåø Some worker branches don't exist yet. Initializing...")
            init_branches_script = orchestrator_dir / "czarina-core" / "init-embedded-branches.sh"
            if init_branches_script.exists():
                result = subprocess.run(
                    ["bash", str(init_branches_script), str(project_root)],
                    input="n\n",  # Auto-answer "no" to pull prompt
                    text=True
                )
                if result.returncode == 0:
                    print("‚úÖ Git branches initialized")
                else:
                    print("‚ö†Ô∏è  Branch initialization had issues, continuing anyway...")
            print()

    # Use orchestrator launch script (v2 with improved UX)
    launch_script_v2 = orchestrator_dir / "czarina-core" / "launch-project-v2.sh"
    launch_script_v1 = orchestrator_dir / "czarina-core" / "launch-project.sh"

    # Prefer v2 if it exists
    if launch_script_v2.exists():
        launch_script = launch_script_v2
    elif launch_script_v1.exists():
        launch_script = launch_script_v1
    else:
        print(f"‚ùå Launch script not found")
        sys.exit(1)

    # Launch via embedded orchestration launcher
    os.chdir(project_root)
    subprocess.run(["bash", str(launch_script), str(czarina_dir)])


def cmd_status(project_name=None):
    """Show project status"""
    czarina_dir, project_root = get_project_context(project_name)

    config_file = czarina_dir / "config.json"
    with open(config_file) as f:
        config = json.load(f)

    print(f"üìä Status: {config['project']['name']}")
    print(f"   Location: {project_root}")
    print(f"   Workers: {len(config['workers'])}")
    print()

    # Check tmux session
    session_name = f"czarina-{config['project']['slug']}"
    result = subprocess.run(
        ["tmux", "has-session", "-t", session_name],
        capture_output=True
    )

    if result.returncode == 0:
        print(f"   Session: ‚úÖ Running ({session_name})")
        print(f"   Attach: tmux attach -t {session_name}")
    else:
        print(f"   Session: ‚ùå Not running")
        print(f"   Start: czarina launch")


def cmd_dashboard(project_name=None):
    """Launch live monitoring dashboard"""
    czarina_dir, project_root = get_project_context(project_name)
    orchestrator_dir = get_orchestrator_dir()
    dashboard_script = orchestrator_dir / "czarina-core" / "dashboard-v2.py"

    if not dashboard_script.exists():
        print(f"‚ùå Dashboard script not found: {dashboard_script}")
        sys.exit(1)

    print("üé≠ Launching dashboard...")
    print("   Press Ctrl+C to exit")
    print()

    os.chdir(project_root)
    subprocess.run([sys.executable, str(dashboard_script)])


def cmd_phase_close(project_name=None, keep_worktrees=False, force_clean=False):
    """Close current phase with smart worktree cleanup"""
    czarina_dir, project_root = get_project_context(project_name)
    orchestrator_dir = get_orchestrator_dir()
    phase_close_script = orchestrator_dir / "czarina-core" / "phase-close.sh"

    if not phase_close_script.exists():
        print(f"‚ùå Phase close script not found: {phase_close_script}")
        sys.exit(1)

    # Build command
    cmd = ["bash", str(phase_close_script), str(czarina_dir)]
    if keep_worktrees:
        cmd.append("--keep-worktrees")
    if force_clean:
        cmd.append("--force-clean")

    os.chdir(project_root)
    subprocess.run(cmd)


def cmd_phase_list(project_name=None):
    """List all phases for project"""
    czarina_dir, project_root = get_project_context(project_name)

    phases_dir = czarina_dir / "phases"

    if not phases_dir.exists():
        print("No phases found")
        return

    print("üìã Phases:")
    for phase_dir in sorted(phases_dir.iterdir()):
        if phase_dir.is_dir():
            summary_file = phase_dir / "PHASE_SUMMARY.md"
            if summary_file.exists():
                # Extract basic info
                with open(summary_file) as f:
                    first_line = f.readline().strip()
                    print(f"  {phase_dir.name}: {first_line}")
            else:
                print(f"  {phase_dir.name}")


def cmd_closeout(project_name=None):
    """Stop all workers, archive logs, and clean up worktrees"""
    czarina_dir, project_root = get_project_context(project_name)
    orchestrator_dir = get_orchestrator_dir()
    closeout_script = orchestrator_dir / "czarina-core" / "closeout-project.sh"

    if not closeout_script.exists():
        print(f"‚ùå Closeout script not found: {closeout_script}")
        sys.exit(1)

    os.chdir(project_root)
    subprocess.run(["bash", str(closeout_script), str(czarina_dir)])


def cmd_daemon_start(project_name=None):
    """Start autonomous daemon for project"""
    czarina_dir, project_root = get_project_context(project_name)
    orchestrator_dir = get_orchestrator_dir()
    daemon_script = orchestrator_dir / "czarina-core" / "daemon" / "start-daemon.sh"

    print("‚ö° Starting daemon...")
    subprocess.run(["bash", str(daemon_script), str(czarina_dir)])


def cmd_daemon_stop(project_name=None):
    """Stop daemon for project"""
    czarina_dir, project_root = get_project_context(project_name)

    config_file = czarina_dir / "config.json"
    with open(config_file) as f:
        config = json.load(f)

    daemon_session = f"{config['project']['slug']}-daemon"
    subprocess.run(["tmux", "kill-session", "-t", daemon_session])
    print(f"‚ö° Daemon stopped")


def cmd_daemon_logs(project_name=None):
    """Show daemon logs for project"""
    czarina_dir, project_root = get_project_context(project_name)
    log_file = czarina_dir / "status" / "daemon.log"

    if log_file.exists():
        subprocess.run(["tail", "-f", str(log_file)])
    else:
        print(f"‚ùå No daemon logs found: {log_file}")


def cmd_daemon_status(project_name=None):
    """Check if daemon is running for project"""
    czarina_dir, project_root = get_project_context(project_name)

    config_file = czarina_dir / "config.json"
    with open(config_file) as f:
        config = json.load(f)

    daemon_session = f"{config['project']['slug']}-daemon"
    result = subprocess.run(
        ["tmux", "has-session", "-t", daemon_session],
        capture_output=True
    )

    if result.returncode == 0:
        print(f"‚ö° Daemon: ‚úÖ Running")
    else:
        print(f"‚ö° Daemon: ‚ùå Not running")
        print(f"   Start: czarina daemon start")


def cmd_hopper(args):
    """Manage the two-level hopper system"""
    orchestrator_dir = get_orchestrator_dir()
    hopper_script = orchestrator_dir / "czarina-core" / "hopper.sh"

    if not hopper_script.exists():
        print(f"‚ùå Hopper script not found: {hopper_script}")
        sys.exit(1)

    # Change to current directory (or project root if in a czarina project)
    czarina_dir, project_root = find_czarina_dir()
    if project_root:
        os.chdir(project_root)

    # Pass all arguments to the hopper script
    subprocess.run(["bash", str(hopper_script)] + args)


def cmd_patterns_update():
    """Update development patterns from upstream"""
    orchestrator_dir = get_orchestrator_dir()
    script_path = orchestrator_dir / "czarina-core" / "patterns" / "update-patterns.sh"
    subprocess.run(["bash", str(script_path)])


def cmd_patterns_version():
    """Show current pattern version"""
    orchestrator_dir = get_orchestrator_dir()
    version_file = orchestrator_dir / "czarina-core" / "patterns" / ".pattern-version"
    if version_file.exists():
        with open(version_file) as f:
            lines = f.readlines()
            version = lines[0].strip()
            if len(lines) > 1:
                updated = lines[1].strip()
                print(f"üìö Pattern version: {version}")
                print(f"üìÖ Last updated: {updated}")
            else:
                print(f"üìö Pattern version: {version}")
    else:
        print("üìö Patterns not yet downloaded")
        print("üí° Run: czarina patterns update")


def cmd_patterns_pending():
    """List patterns ready to contribute upstream"""
    orchestrator_dir = get_orchestrator_dir()
    inbox_patterns = orchestrator_dir / "czarina-inbox" / "patterns"

    if not inbox_patterns.exists():
        inbox_patterns.mkdir(parents=True)

    patterns = list(inbox_patterns.glob("*.md"))

    if not patterns:
        print("üìù No patterns pending contribution")
        print("üí° Document patterns in: czarina-inbox/patterns/")
        return

    print("üìù Patterns ready to contribute:\n")
    for pattern in sorted(patterns):
        with open(pattern) as f:
            content = f.read()
            has_example = "```" in content or "Example" in content
            has_metrics = any(word in content for word in ["Value:", "%", "reduction", "improvement"])

            if has_example and has_metrics:
                status = "‚úÖ Ready"
            elif has_example or has_metrics:
                status = "‚ö†Ô∏è  Needs improvement"
            else:
                status = "‚ùå Incomplete"

        print(f"  {pattern.name:40} {status}")

    print(f"\nüí° Use 'czarina patterns contribute' to submit upstream")


def cmd_patterns_contribute():
    """Show contribution guide"""
    orchestrator_dir = get_orchestrator_dir()
    guide = orchestrator_dir / "czarina-core" / "patterns" / "PATTERN_CONTRIBUTION_GUIDE.md"

    if guide.exists():
        with open(guide) as f:
            lines = f.readlines()[:50]
            print("".join(lines))
            if len(lines) >= 50:
                print(f"\nüìñ Read full guide: {guide}")
    else:
        print("üìñ Contribution guide not found")

    print("\nüìù Quick start:")
    print("  1. Document pattern in: czarina-inbox/patterns/")
    print("  2. Check pending: czarina patterns pending")
    print("  3. Follow guide to submit upstream")


def cmd_memory_init(project_name=None):
    """Initialize memory system for the project"""
    czarina_dir, project_root = get_project_context(project_name)

    # Import memory module
    sys.path.insert(0, str(get_orchestrator_dir() / "czarina-core"))
    from memory import MemorySystem

    # Determine embedding provider (check for OpenAI API key)
    provider = "openai" if os.environ.get("OPENAI_API_KEY") else "local"

    if provider == "local":
        print("‚ÑπÔ∏è  OPENAI_API_KEY not found, using local embeddings")
        print("   To use OpenAI: export OPENAI_API_KEY=your-key")
        print()

    memory = MemorySystem(czarina_dir, embedding_provider=provider)

    # Get project name from config
    config_file = czarina_dir / "config.json"
    if config_file.exists():
        with open(config_file) as f:
            config = json.load(f)
            project_name = config.get("project", {}).get("name", "My Project")
    else:
        project_name = project_name or project_root.name

    memory.initialize_memories_file(project_name)

    print()
    print("üìù Next steps:")
    print("  1. Edit .czarina/memories.md to add architectural context")
    print("  2. Run 'czarina memory rebuild' to build the search index")
    print("  3. Use 'czarina memory query \"task\"' to search memories")


def cmd_memory_rebuild():
    """Rebuild the vector index from memories.md"""
    czarina_dir, project_root = get_project_context()

    sys.path.insert(0, str(get_orchestrator_dir() / "czarina-core"))
    from memory import MemorySystem

    memories_file = czarina_dir / "memories.md"
    if not memories_file.exists():
        print("‚ùå memories.md not found")
        print("üí° Run 'czarina memory init' first")
        sys.exit(1)

    # Determine embedding provider
    provider = "openai" if os.environ.get("OPENAI_API_KEY") else "local"

    if provider == "local":
        print("‚ÑπÔ∏è  Using local embeddings (sentence-transformers)")
        print()

    memory = MemorySystem(czarina_dir, embedding_provider=provider)
    metadata = memory.build_index(verbose=True)

    print()
    print(f"‚úÖ Index rebuilt successfully")
    print(f"   Model: {metadata['embedding_model']}")
    print(f"   Chunks: {metadata['chunk_count']}")


def cmd_memory_query(query_text: str, top_k: int = 5):
    """Query memories for relevant context"""
    czarina_dir, project_root = get_project_context()

    sys.path.insert(0, str(get_orchestrator_dir() / "czarina-core"))
    from memory import MemorySystem

    memories_file = czarina_dir / "memories.md"
    if not memories_file.exists():
        print("‚ùå memories.md not found")
        print("üí° Run 'czarina memory init' first")
        sys.exit(1)

    # Determine embedding provider
    provider = "openai" if os.environ.get("OPENAI_API_KEY") else "local"

    memory = MemorySystem(czarina_dir, embedding_provider=provider)

    print(f"üîç Searching memories for: \"{query_text}\"")
    print()

    results = memory.query(query_text, top_k=top_k)

    if not results:
        print("No relevant memories found.")
        return

    print("=" * 70)
    print(memory.format_context(results))
    print("=" * 70)
    print()
    print(f"Found {len(results)} relevant memories")


def cmd_memory_extract():
    """Extract learnings from current session to memories.md"""
    czarina_dir, project_root = get_project_context()

    sys.path.insert(0, str(get_orchestrator_dir() / "czarina-core"))
    from memory import MemorySystem

    memories_file = czarina_dir / "memories.md"
    if not memories_file.exists():
        print("‚ùå memories.md not found")
        print("üí° Run 'czarina memory init' first")
        sys.exit(1)

    print("üìù Session Extraction")
    print("=" * 70)
    print()
    print("Please provide a session summary in markdown format.")
    print("Press Ctrl+D (Unix) or Ctrl+Z (Windows) when done.")
    print()
    print("Template:")
    print("### Session: YYYY-MM-DD - [Description]")
    print()
    print("**What We Did:**")
    print("- ")
    print()
    print("**What Broke:**")
    print("- ")
    print()
    print("**Root Cause:**")
    print("- ")
    print()
    print("**Resolution:**")
    print("- ")
    print()
    print("**Learnings:**")
    print("- ")
    print()
    print("=" * 70)
    print()
    print("Enter your session summary:")

    # Read multiline input
    lines = []
    try:
        while True:
            line = input()
            lines.append(line)
    except EOFError:
        pass

    session_summary = "\n".join(lines).strip()

    if not session_summary:
        print("\n‚ùå Empty summary, aborting")
        sys.exit(1)

    memory = MemorySystem(czarina_dir)
    success = memory.extract_session(session_summary)

    if success:
        print()
        print("üí° Don't forget to rebuild the index:")
        print("   czarina memory rebuild")


def cmd_memory_show_core():
    """Show the architectural core (always-loaded context)"""
    czarina_dir, project_root = get_project_context()

    sys.path.insert(0, str(get_orchestrator_dir() / "czarina-core"))
    from memory import MemorySystem

    memories_file = czarina_dir / "memories.md"
    if not memories_file.exists():
        print("‚ùå memories.md not found")
        print("üí° Run 'czarina memory init' first")
        sys.exit(1)

    memory = MemorySystem(czarina_dir)
    core = memory.get_architectural_core()

    if core:
        print("=" * 70)
        print(core)
        print("=" * 70)
    else:
        print("No architectural core found in memories.md")


def cmd_deps_check(worker_id=None):
    """Check dependency status for a worker or all workers"""
    czarina_dir, project_root = get_project_context()

    config_file = czarina_dir / "config.json"
    with open(config_file) as f:
        config = json.load(f)

    workers = config["workers"]

    if worker_id:
        # Check specific worker
        worker = next((w for w in workers if w["id"] == worker_id), None)
        if not worker:
            print(f"‚ùå Worker not found: {worker_id}")
            sys.exit(1)
        workers_to_check = [worker]
    else:
        # Check all workers
        workers_to_check = workers

    print("üîç Dependency Check")
    print("=" * 60)
    print()

    os.chdir(project_root)

    for worker in workers_to_check:
        wid = worker["id"]
        branch = worker.get("branch", "")
        role = worker.get("role", "worker")
        deps = worker.get("dependencies", [])
        merges = worker.get("merges", [])

        print(f"üìã Worker: {wid}")
        print(f"   Branch: {branch}")
        print(f"   Role: {role}")

        if not deps and not merges:
            print(f"   Dependencies: None")
            print()
            continue

        # Check dependencies
        if deps:
            print(f"   Dependencies:")
            for dep_id in deps:
                dep_worker = next((w for w in workers if w["id"] == dep_id), None)
                if not dep_worker:
                    print(f"      ‚ùå {dep_id} - not found in config")
                    continue

                dep_branch = dep_worker.get("branch", "")
                # Check if branch exists
                result = subprocess.run(
                    ["git", "show-ref", "--verify", "--quiet", f"refs/heads/{dep_branch}"],
                    capture_output=True
                )
                local_exists = result.returncode == 0

                result = subprocess.run(
                    ["git", "show-ref", "--verify", "--quiet", f"refs/remotes/origin/{dep_branch}"],
                    capture_output=True
                )
                remote_exists = result.returncode == 0

                if remote_exists or local_exists:
                    location = []
                    if local_exists:
                        location.append("local")
                    if remote_exists:
                        location.append("remote")
                    print(f"      ‚úÖ {dep_id} ({dep_branch}) - {', '.join(location)}")
                else:
                    print(f"      ‚ö†Ô∏è  {dep_id} ({dep_branch}) - not started yet")

        # Check merges (for integration workers)
        if merges:
            print(f"   Required Merges:")
            for merge_id in merges:
                merge_worker = next((w for w in workers if w["id"] == merge_id), None)
                if not merge_worker:
                    print(f"      ‚ùå {merge_id} - not found in config")
                    continue

                merge_branch = merge_worker.get("branch", "")

                # Check if branch exists
                result = subprocess.run(
                    ["git", "show-ref", "--verify", "--quiet", f"refs/remotes/origin/{merge_branch}"],
                    capture_output=True
                )
                branch_exists = result.returncode == 0

                if not branch_exists:
                    print(f"      ‚ö†Ô∏è  {merge_id} ({merge_branch}) - not pushed yet")
                    continue

                # Check if merged into current worker branch
                if not branch:
                    print(f"      ‚ö†Ô∏è  {merge_id} - can't check (no branch specified)")
                    continue

                # Check if merge_branch is ancestor of worker branch
                result = subprocess.run(
                    ["git", "merge-base", "--is-ancestor", merge_branch, branch],
                    capture_output=True
                )
                is_merged = result.returncode == 0

                if is_merged:
                    print(f"      ‚úÖ {merge_id} ({merge_branch}) - MERGED")
                else:
                    print(f"      ‚ùå {merge_id} ({merge_branch}) - NOT MERGED")

        print()

    print("üí° Tip: Integration workers must merge all branches in 'merges' before pushing")
    print("   The pre-push hook will enforce this automatically")


def cmd_deps_validate(worker_id):
    """Validate that a worker's dependencies are ready for their work"""
    czarina_dir, project_root = get_project_context()

    config_file = czarina_dir / "config.json"
    with open(config_file) as f:
        config = json.load(f)

    worker = next((w for w in config["workers"] if w["id"] == worker_id), None)
    if not worker:
        print(f"‚ùå Worker not found: {worker_id}")
        sys.exit(1)

    deps = worker.get("dependencies", [])
    merges = worker.get("merges", [])

    if not deps and not merges:
        print(f"‚úÖ Worker '{worker_id}' has no dependencies")
        return

    print(f"üîç Validating dependencies for: {worker_id}")
    print()

    os.chdir(project_root)

    all_ready = True

    # Check if dependencies have pushed their work
    for dep_id in deps:
        dep_worker = next((w for w in config["workers"] if w["id"] == dep_id), None)
        if not dep_worker:
            print(f"‚ùå Dependency '{dep_id}' not found in config")
            all_ready = False
            continue

        dep_branch = dep_worker.get("branch", "")
        result = subprocess.run(
            ["git", "show-ref", "--verify", "--quiet", f"refs/remotes/origin/{dep_branch}"],
            capture_output=True
        )

        if result.returncode == 0:
            print(f"‚úÖ {dep_id} - work available on remote")
        else:
            print(f"‚ùå {dep_id} - not pushed to remote yet")
            all_ready = False

    print()

    if all_ready:
        print(f"‚úÖ All dependencies ready for '{worker_id}' to proceed")
    else:
        print(f"‚ö†Ô∏è  Some dependencies not ready yet")
        print(f"   Worker '{worker_id}' should wait for dependencies to complete")


def cmd_analyze(plan_file, output_file=None, auto_init=False, interactive=False):
    """
    Analyze implementation plan and suggest orchestration setup

    Launches Claude Code to help create czarina orchestration from plan file.
    """
    orchestrator_dir = get_orchestrator_dir()

    print("üîç Czarina Project Analysis")
    print("=" * 60)
    print()

    # Check if plan file exists
    plan_path = Path(plan_file).resolve()
    if not plan_path.exists():
        print(f"‚ùå Plan file not found: {plan_file}")
        sys.exit(1)

    print(f"üìÑ Input Plan: {plan_file}")
    print()

    # Create .czarina directory if it doesn't exist
    current_dir = Path.cwd()
    czarina_dir = current_dir / ".czarina"

    if not czarina_dir.exists():
        print("üìÅ Creating .czarina directory structure...")
        czarina_dir.mkdir()
        (czarina_dir / "workers").mkdir()
        print("   ‚úÖ Created .czarina/")
        print("   ‚úÖ Created .czarina/workers/")
        print()

    # Build Claude Code prompt
    prompt = f"""Read the implementation plan at {plan_path} and help me set up a czarina orchestration.

Please:
1. Analyze the plan and identify the key workers needed
2. Create a config.json file in .czarina/ with the project structure
3. Create worker definition markdown files in .czarina/workers/ for each worker
4. Follow the czarina configuration format (see examples in czarina-core/templates/ if available)

The config.json should include:
- project metadata (name, slug, version, phase)
- worker definitions (id, branch, dependencies)
- any special configuration (hopper, orchestration mode, etc.)

CRITICAL - Branch Naming Convention:
- Worker branches MUST follow the pattern: cz<phase>/feat/<worker-id>
- Omnibus branch MUST follow the pattern: cz<phase>/release/v<version>
- For example, if phase is "1" or "implementation":
  * Worker branch: cz1/feat/logging OR czimplementation/feat/logging
  * Omnibus branch: cz1/release/v0.6.0 OR czimplementation/release/v0.6.0
- DO NOT use the old "worker/" prefix - it will fail validation!

Each worker markdown file should include:
- Mission and deliverables
- Detailed task breakdown
- References to relevant documentation

Let's get started!"""

    print("üöÄ Launching Claude Code to help with orchestration setup...")
    print()
    print("üí° Claude will help you create:")
    print("   - .czarina/config.json")
    print("   - .czarina/workers/*.md files")
    print()

    # Launch Claude Code
    try:
        import subprocess
        subprocess.run(["claude", prompt], check=True)

        print()
        print("=" * 60)
        print()
        print("‚úÖ Claude Code session complete!")
        print()
        print("üìã Next steps:")
        print("   1. Verify .czarina/config.json was created")
        print("   2. Verify .czarina/workers/*.md files exist")
        print("   3. Launch the orchestration:")
        print("      czarina launch")
        print()

    except FileNotFoundError:
        print()
        print("‚ùå Error: 'claude' command not found")
        print("   Please install Claude Code CLI: https://code.claude.com")
        print()
        sys.exit(1)

    except Exception as e:
        print()
        print(f"‚ùå Failed to launch Claude Code: {e}")
        print()
        sys.exit(1)

    print("=" * 60)


def show_usage():
    """Show usage information"""
    print(__doc__)
    print("\nExamples:")
    print("  # Interactive analysis (works with Claude Code, Cursor, any agent!)")
    print("  czarina analyze implementation-plan.md --interactive --init")
    print("")
    print("  # Automated analysis (requires Anthropic API key)")
    print("  czarina analyze implementation-plan.md --init")
    print("")
    print("  # Analyze and save to file (no init)")
    print("  czarina analyze implementation-plan.md --output analysis.json")
    print("")
    print("  # Manual initialization")
    print("  cd ~/my-project && czarina init")
    print("")
    print("  # Launch from project directory")
    print("  cd ~/my-project && czarina launch")
    print("")
    print("  # Launch from anywhere by name")
    print("  czarina launch my-project")
    print("")
    print("  # Daemon and patterns")
    print("  czarina daemon start")
    print("  czarina patterns update")
    print("  czarina list")


def main():
    if len(sys.argv) < 2:
        show_usage()
        sys.exit(1)

    command = sys.argv[1]

    if command == "analyze":
        if len(sys.argv) < 3:
            print("‚ùå Usage: czarina analyze <plan-file> [--output file.json] [--init] [--interactive]")
            sys.exit(1)
        plan_file = sys.argv[2]
        output_file = None
        auto_init = False
        interactive = False
        # Parse optional flags
        for i in range(3, len(sys.argv)):
            if sys.argv[i] == "--output" and i + 1 < len(sys.argv):
                output_file = sys.argv[i + 1]
            elif sys.argv[i] == "--init":
                auto_init = True
            elif sys.argv[i] == "--interactive":
                interactive = True
        cmd_analyze(plan_file, output_file, auto_init, interactive)
    elif command == "init":
        # Check for --from-config, --from-plan, and --force flags
        from_config = None
        from_plan = None
        project_name = None
        force = False

        i = 2
        while i < len(sys.argv):
            arg = sys.argv[i]
            if arg == "--from-config":
                if i + 1 < len(sys.argv):
                    from_config = sys.argv[i + 1]
                    i += 2
                else:
                    print("‚ùå --from-config requires a file path")
                    sys.exit(1)
            elif arg == "--from-plan" or arg == "--plan":
                if i + 1 < len(sys.argv):
                    from_plan = sys.argv[i + 1]
                    i += 2
                else:
                    print("‚ùå --plan requires a file path")
                    sys.exit(1)
            elif arg == "--force":
                force = True
                i += 1
            elif not arg.startswith("--"):
                project_name = arg
                i += 1
            else:
                i += 1

        cmd_init(project_name, from_config, from_plan, force)
    elif command == "launch":
        project_name = sys.argv[2] if len(sys.argv) > 2 else None
        cmd_launch(project_name)
    elif command == "status":
        project_name = sys.argv[2] if len(sys.argv) > 2 else None
        cmd_status(project_name)
    elif command == "dashboard":
        project_name = sys.argv[2] if len(sys.argv) > 2 else None
        cmd_dashboard(project_name)
    elif command == "phase":
        if len(sys.argv) < 3:
            print("‚ùå Usage: czarina phase <close|list> [options]")
            sys.exit(1)
        phase_cmd = sys.argv[2]
        if phase_cmd == "close":
            # Parse flags and project name
            project_name = None
            keep_worktrees = False
            force_clean = False

            for i in range(3, len(sys.argv)):
                arg = sys.argv[i]
                if arg == "--keep-worktrees":
                    keep_worktrees = True
                elif arg == "--force-clean":
                    force_clean = True
                elif not arg.startswith("--"):
                    project_name = arg

            cmd_phase_close(project_name, keep_worktrees, force_clean)
        elif phase_cmd == "list":
            project_name = sys.argv[3] if len(sys.argv) > 3 else None
            cmd_phase_list(project_name)
        else:
            print(f"‚ùå Unknown phase command: {phase_cmd}")
            print("   Available: close, list")
            sys.exit(1)
    elif command == "closeout":
        project_name = sys.argv[2] if len(sys.argv) > 2 else None
        cmd_closeout(project_name)
    elif command == "daemon":
        if len(sys.argv) < 3:
            print("‚ùå Usage: czarina daemon <start|stop|logs|status> [project]")
            sys.exit(1)
        subcommand = sys.argv[2]
        project_name = sys.argv[3] if len(sys.argv) > 3 else None
        if subcommand == "start":
            cmd_daemon_start(project_name)
        elif subcommand == "stop":
            cmd_daemon_stop(project_name)
        elif subcommand == "logs":
            cmd_daemon_logs(project_name)
        elif subcommand == "status":
            cmd_daemon_status(project_name)
        else:
            print(f"‚ùå Unknown daemon subcommand: {subcommand}")
            print("   Valid: start, stop, logs, status")
            sys.exit(1)
    elif command == "hopper":
        # Pass remaining arguments to hopper script
        hopper_args = sys.argv[2:] if len(sys.argv) > 2 else []
        cmd_hopper(hopper_args)
    elif command == "memory":
        if len(sys.argv) < 3:
            print("‚ùå Usage: czarina memory <init|query|rebuild|extract|core>")
            sys.exit(1)
        subcommand = sys.argv[2]
        if subcommand == "init":
            project_name = sys.argv[3] if len(sys.argv) > 3 else None
            cmd_memory_init(project_name)
        elif subcommand == "query":
            if len(sys.argv) < 4:
                print("‚ùå Usage: czarina memory query \"<text>\"")
                sys.exit(1)
            query_text = " ".join(sys.argv[3:])
            # Check for optional --top-k flag
            top_k = 5
            if "--top-k" in sys.argv:
                idx = sys.argv.index("--top-k")
                if idx + 1 < len(sys.argv):
                    try:
                        top_k = int(sys.argv[idx + 1])
                        # Remove --top-k and its value from query_text
                        query_parts = sys.argv[3:]
                        query_parts.remove("--top-k")
                        query_parts.remove(sys.argv[idx + 1])
                        query_text = " ".join(query_parts)
                    except ValueError:
                        pass
            cmd_memory_query(query_text, top_k)
        elif subcommand == "rebuild":
            cmd_memory_rebuild()
        elif subcommand == "extract":
            cmd_memory_extract()
        elif subcommand == "core":
            cmd_memory_show_core()
        else:
            print(f"‚ùå Unknown memory subcommand: {subcommand}")
            print("   Valid: init, query, rebuild, extract, core")
            sys.exit(1)
    elif command == "patterns":
        if len(sys.argv) < 3:
            print("‚ùå Usage: czarina patterns <update|version|pending|contribute>")
            sys.exit(1)
        subcommand = sys.argv[2]
        if subcommand == "update":
            cmd_patterns_update()
        elif subcommand == "version":
            cmd_patterns_version()
        elif subcommand == "pending":
            cmd_patterns_pending()
        elif subcommand == "contribute":
            cmd_patterns_contribute()
        else:
            print(f"‚ùå Unknown patterns subcommand: {subcommand}")
            print("   Valid: update, version, pending, contribute")
            sys.exit(1)
    elif command == "deps":
        if len(sys.argv) < 3:
            print("‚ùå Usage: czarina deps <check|validate> [worker-id]")
            sys.exit(1)
        subcommand = sys.argv[2]
        if subcommand == "check":
            worker_id = sys.argv[3] if len(sys.argv) > 3 else None
            cmd_deps_check(worker_id)
        elif subcommand == "validate":
            if len(sys.argv) < 4:
                print("‚ùå Usage: czarina deps validate <worker-id>")
                sys.exit(1)
            worker_id = sys.argv[3]
            cmd_deps_validate(worker_id)
        else:
            print(f"‚ùå Unknown deps subcommand: {subcommand}")
            print("   Valid: check, validate")
            sys.exit(1)
    elif command in ["version", "-v", "--version"]:
        print(f"Czarina v{CZARINA_VERSION}")
        print("Multi-Agent Orchestration CLI")
        print()
        print("Repository: https://github.com/apathy-ca/czarina")
        print("Documentation: https://github.com/apathy-ca/czarina/tree/main/docs")
    elif command in ["-h", "--help", "help"]:
        show_usage()
    else:
        print(f"‚ùå Unknown command: {command}")
        show_usage()
        sys.exit(1)


if __name__ == "__main__":
    main()
