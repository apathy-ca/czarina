#!/usr/bin/env python3
"""
Czarina - Multi-Agent Orchestration CLI
Simple interface for managing multi-agent orchestration projects

Usage:
    czarina analyze <plan-file>                  - Analyze plan and suggest orchestration
    czarina analyze <plan-file> --interactive    - Interactive mode (works with any AI agent!)
    czarina analyze <plan-file> --init           - Analyze and initialize project
    czarina analyze <plan-file> --output file    - Save analysis to file
    czarina init [project-name]                  - Initialize orchestration in current dir
    czarina list                                 - List all Czarina projects
    czarina launch [project]                     - Launch project workers
    czarina status [project]                     - Show project status
    czarina daemon start [project]               - Start autonomous daemon
    czarina daemon stop [project]                - Stop daemon
    czarina daemon logs [project]                - Show daemon logs
    czarina daemon status [project]              - Check daemon status
    czarina patterns update                      - Update pattern library
    czarina patterns version                     - Show pattern version
    czarina patterns pending                     - List patterns ready to contribute
    czarina patterns contribute                  - Show contribution guide
"""

import sys
import subprocess
import json
import os
from pathlib import Path
from datetime import datetime

# Add czarina-core to path for imports
# Resolve symlinks to find the actual repository location
sys.path.insert(0, str(Path(__file__).resolve().parent / "czarina-core"))


def get_orchestrator_dir():
    """Get the orchestrator root directory"""
    return Path(__file__).resolve().parent


def find_czarina_dir(start_path=None):
    """
    Find .czarina/ directory by searching up from start_path
    Returns (czarina_dir, project_root) or (None, None)
    """
    if start_path is None:
        start_path = Path.cwd()
    else:
        start_path = Path(start_path).resolve()

    current = start_path
    while current != current.parent:
        czarina_dir = current / ".czarina"
        if czarina_dir.exists() and czarina_dir.is_dir():
            return czarina_dir, current
        current = current.parent

    return None, None


def find_project_by_name(project_name):
    """
    Search for a project by name in common locations
    Returns (czarina_dir, project_root) or (None, None)
    """
    # Search in home directory projects
    home = Path.home()
    search_paths = [
        home / "projects",
        home / "Source",
        home / "Source" / "GRID",
        home / "code",
        home / "dev",
    ]

    for base in search_paths:
        if not base.exists():
            continue
        for item in base.rglob(".czarina"):
            if item.is_dir():
                config_file = item / "config.json"
                if config_file.exists():
                    try:
                        with open(config_file) as f:
                            config = json.load(f)
                            if config.get("project", {}).get("slug") == project_name:
                                return item, item.parent
                    except:
                        pass

    return None, None


def get_project_context(project_name=None):
    """
    Get project context (czarina_dir and project_root)

    Priority:
    1. If project_name given, search for it
    2. Look for .czarina/ in current directory or parents
    3. Fail with helpful message
    """
    if project_name:
        czarina_dir, project_root = find_project_by_name(project_name)
        if czarina_dir:
            return czarina_dir, project_root
        print(f"‚ùå Project '{project_name}' not found")
        print(f"üí° Run 'czarina list' to see available projects")
        sys.exit(1)

    # Try current directory
    czarina_dir, project_root = find_czarina_dir()
    if czarina_dir:
        return czarina_dir, project_root

    print("‚ùå No Czarina project found")
    print("üí° Run 'czarina init' in your project directory")
    print("üí° Or specify project name: 'czarina launch <project>'")
    sys.exit(1)


def cmd_init(project_name=None):
    """Initialize Czarina orchestration in current directory"""
    current_dir = Path.cwd()

    # Check if already initialized
    czarina_dir = current_dir / ".czarina"
    if czarina_dir.exists():
        print(f"‚ùå Czarina already initialized in {current_dir}")
        print(f"   .czarina/ directory exists")
        sys.exit(1)

    # Detect project name from directory or use provided
    if not project_name:
        project_name = current_dir.name

    slug = project_name.lower().replace(" ", "-")

    # Create .czarina/ structure
    czarina_dir.mkdir()
    (czarina_dir / "workers").mkdir()
    (czarina_dir / "status").mkdir()

    # Create config.json
    config = {
        "project": {
            "name": project_name,
            "slug": slug,
            "repository": str(current_dir),
            "orchestration_dir": ".czarina"
        },
        "workers": [
            {
                "id": "worker1",
                "agent": "aider",
                "branch": f"feat/{slug}-worker1",
                "description": "Worker 1"
            }
        ],
        "daemon": {
            "enabled": True,
            "auto_approve": ["read", "write", "commit"]
        }
    }

    config_file = czarina_dir / "config.json"
    with open(config_file, "w") as f:
        json.dump(config, f, indent=2)

    # Create example worker prompt
    worker_file = czarina_dir / "workers" / "worker1.md"
    with open(worker_file, "w") as f:
        f.write(f"""# Worker 1 - {project_name}

## Role
[Describe this worker's role]

## Responsibilities
- [Responsibility 1]
- [Responsibility 2]

## Files
- [Files this worker should work on]

## Git Workflow
Branch: feat/{slug}-worker1

When your work is complete:
1. Commit your changes
2. Push to your branch
3. Create a PR to main
4. Wait for review

## Pattern Library
Before starting, review:
- czarina-core/patterns/ERROR_RECOVERY_PATTERNS.md
- czarina-core/patterns/CZARINA_PATTERNS.md
""")

    # Create .worker-init script for auto-discovery
    worker_init = czarina_dir / ".worker-init"
    orchestrator_dir = get_orchestrator_dir()
    with open(worker_init, "w") as f:
        f.write(f"""#!/bin/bash
# Czarina Worker Auto-Init
# This script helps workers discover their role and setup

CZARINA_DIR="$(cd "$(dirname "${{BASH_SOURCE[0]}}")" && pwd)"
CONFIG_FILE="$CZARINA_DIR/config.json"

if [ ! -f "$CONFIG_FILE" ]; then
    echo "‚ùå Config file not found: $CONFIG_FILE"
    exit 1
fi

# Show available workers
echo "üìã Available workers:"
jq -r '.workers[] | "  ‚Ä¢ \\(.id) - \\(.description)"' "$CONFIG_FILE"
echo ""

# If worker ID provided, load it
if [ -n "$1" ]; then
    WORKER_ID="$1"
    WORKER_FILE="$CZARINA_DIR/workers/$WORKER_ID.md"

    if [ -f "$WORKER_FILE" ]; then
        echo "‚úÖ Loading worker: $WORKER_ID"
        cat "$WORKER_FILE"
    else
        echo "‚ùå Worker file not found: $WORKER_FILE"
        exit 1
    fi
else
    echo "üí° Usage: ./.czarina/.worker-init <worker-id>"
fi
""")
    worker_init.chmod(0o755)

    # Create README
    readme = czarina_dir / "README.md"
    with open(readme, "w") as f:
        f.write(f"""# Czarina Orchestration - {project_name}

## Quick Start

### For Workers

**Claude Code / Desktop:**
```bash
./.czarina/.worker-init worker1
```

**Claude Code Web (auto-discovery):**
Just say: "You are worker1"

### For Orchestrators

**Launch all workers:**
```bash
czarina launch
```

**Start daemon (auto-approval):**
```bash
czarina daemon start
```

**Check status:**
```bash
czarina status
```

## Configuration

Edit `.czarina/config.json` to:
- Add/remove workers
- Configure agent types
- Set daemon behavior

Edit `.czarina/workers/*.md` to define worker roles and tasks.

## Workers

{chr(10).join(f"- **{w['id']}**: {w['description']}" for w in config['workers'])}

## Project

**Repository:** {current_dir}
**Orchestration:** .czarina/

Created: {datetime.now().strftime('%Y-%m-%d')}
""")

    # Update .gitignore
    gitignore = current_dir / ".gitignore"
    gitignore_content = ""
    if gitignore.exists():
        gitignore_content = gitignore.read_text()

    if ".czarina/status/" not in gitignore_content:
        with open(gitignore, "a") as f:
            if gitignore_content and not gitignore_content.endswith("\n"):
                f.write("\n")
            f.write("\n# Czarina orchestration\n")
            f.write(".czarina/status/\n")

    print("‚úÖ Czarina initialized successfully!")
    print(f"\nüìÅ Created in: {current_dir}")
    print(f"üìã Project: {project_name} ({slug})")
    print(f"\nüìù Next steps:")
    print(f"  1. Edit .czarina/config.json - configure workers")
    print(f"  2. Edit .czarina/workers/*.md - define worker roles")
    print(f"  3. git add .czarina/")
    print(f"  4. git commit -m 'Add Czarina orchestration'")
    print(f"  5. czarina launch")
    print(f"\nüí° Read more: {orchestrator_dir}/docs/guides/WORKER_SETUP_GUIDE.md")


def cmd_list():
    """List all Czarina projects"""
    home = Path.home()
    search_paths = [
        home / "projects",
        home / "Source",
        home / "Source" / "GRID",
        home / "code",
        home / "dev",
    ]

    projects = []
    for base in search_paths:
        if not base.exists():
            continue
        for item in base.rglob(".czarina"):
            if item.is_dir():
                config_file = item / "config.json"
                if config_file.exists():
                    try:
                        with open(config_file) as f:
                            config = json.load(f)
                            projects.append({
                                "name": config.get("project", {}).get("name", "Unknown"),
                                "slug": config.get("project", {}).get("slug", "unknown"),
                                "path": item.parent,
                                "workers": len(config.get("workers", []))
                            })
                    except:
                        pass

    if not projects:
        print("üìã No Czarina projects found")
        print("üí° Run 'czarina init' in a project directory to create one")
        return

    print("üìã Czarina Projects:\n")
    for p in sorted(projects, key=lambda x: x["name"]):
        print(f"  ‚Ä¢ {p['name']} ({p['slug']})")
        print(f"    Path: {p['path']}")
        print(f"    Workers: {p['workers']}")
        print()


def cmd_launch(project_name=None):
    """Launch workers for project"""
    czarina_dir, project_root = get_project_context(project_name)

    # Load config
    config_file = czarina_dir / "config.json"
    with open(config_file) as f:
        config = json.load(f)

    project_slug = config["project"]["slug"]
    workers = config["workers"]

    print(f"üöÄ Launching: {config['project']['name']}")
    print(f"   Workers: {len(workers)}")
    print(f"   Project: {project_root}")
    print()

    # Use orchestrator launch script
    orchestrator_dir = get_orchestrator_dir()
    launch_script = orchestrator_dir / "czarina-core" / "launch-project.sh"

    if not launch_script.exists():
        print(f"‚ùå Launch script not found: {launch_script}")
        sys.exit(1)

    # Launch via embedded orchestration launcher
    os.chdir(project_root)
    subprocess.run(["bash", str(launch_script), str(czarina_dir)])


def cmd_status(project_name=None):
    """Show project status"""
    czarina_dir, project_root = get_project_context(project_name)

    config_file = czarina_dir / "config.json"
    with open(config_file) as f:
        config = json.load(f)

    print(f"üìä Status: {config['project']['name']}")
    print(f"   Location: {project_root}")
    print(f"   Workers: {len(config['workers'])}")
    print()

    # Check tmux session
    session_name = f"czarina-{config['project']['slug']}"
    result = subprocess.run(
        ["tmux", "has-session", "-t", session_name],
        capture_output=True
    )

    if result.returncode == 0:
        print(f"   Session: ‚úÖ Running ({session_name})")
        print(f"   Attach: tmux attach -t {session_name}")
    else:
        print(f"   Session: ‚ùå Not running")
        print(f"   Start: czarina launch")


def cmd_daemon_start(project_name=None):
    """Start autonomous daemon for project"""
    czarina_dir, project_root = get_project_context(project_name)
    orchestrator_dir = get_orchestrator_dir()
    daemon_script = orchestrator_dir / "czarina-core" / "daemon" / "start-daemon.sh"

    print("‚ö° Starting daemon...")
    subprocess.run(["bash", str(daemon_script), str(czarina_dir)])


def cmd_daemon_stop(project_name=None):
    """Stop daemon for project"""
    czarina_dir, project_root = get_project_context(project_name)

    config_file = czarina_dir / "config.json"
    with open(config_file) as f:
        config = json.load(f)

    daemon_session = f"{config['project']['slug']}-daemon"
    subprocess.run(["tmux", "kill-session", "-t", daemon_session])
    print(f"‚ö° Daemon stopped")


def cmd_daemon_logs(project_name=None):
    """Show daemon logs for project"""
    czarina_dir, project_root = get_project_context(project_name)
    log_file = czarina_dir / "status" / "daemon.log"

    if log_file.exists():
        subprocess.run(["tail", "-f", str(log_file)])
    else:
        print(f"‚ùå No daemon logs found: {log_file}")


def cmd_daemon_status(project_name=None):
    """Check if daemon is running for project"""
    czarina_dir, project_root = get_project_context(project_name)

    config_file = czarina_dir / "config.json"
    with open(config_file) as f:
        config = json.load(f)

    daemon_session = f"{config['project']['slug']}-daemon"
    result = subprocess.run(
        ["tmux", "has-session", "-t", daemon_session],
        capture_output=True
    )

    if result.returncode == 0:
        print(f"‚ö° Daemon: ‚úÖ Running")
    else:
        print(f"‚ö° Daemon: ‚ùå Not running")
        print(f"   Start: czarina daemon start")


def cmd_patterns_update():
    """Update development patterns from upstream"""
    orchestrator_dir = get_orchestrator_dir()
    script_path = orchestrator_dir / "czarina-core" / "patterns" / "update-patterns.sh"
    subprocess.run(["bash", str(script_path)])


def cmd_patterns_version():
    """Show current pattern version"""
    orchestrator_dir = get_orchestrator_dir()
    version_file = orchestrator_dir / "czarina-core" / "patterns" / ".pattern-version"
    if version_file.exists():
        with open(version_file) as f:
            lines = f.readlines()
            version = lines[0].strip()
            if len(lines) > 1:
                updated = lines[1].strip()
                print(f"üìö Pattern version: {version}")
                print(f"üìÖ Last updated: {updated}")
            else:
                print(f"üìö Pattern version: {version}")
    else:
        print("üìö Patterns not yet downloaded")
        print("üí° Run: czarina patterns update")


def cmd_patterns_pending():
    """List patterns ready to contribute upstream"""
    orchestrator_dir = get_orchestrator_dir()
    inbox_patterns = orchestrator_dir / "czarina-inbox" / "patterns"

    if not inbox_patterns.exists():
        inbox_patterns.mkdir(parents=True)

    patterns = list(inbox_patterns.glob("*.md"))

    if not patterns:
        print("üìù No patterns pending contribution")
        print("üí° Document patterns in: czarina-inbox/patterns/")
        return

    print("üìù Patterns ready to contribute:\n")
    for pattern in sorted(patterns):
        with open(pattern) as f:
            content = f.read()
            has_example = "```" in content or "Example" in content
            has_metrics = any(word in content for word in ["Value:", "%", "reduction", "improvement"])

            if has_example and has_metrics:
                status = "‚úÖ Ready"
            elif has_example or has_metrics:
                status = "‚ö†Ô∏è  Needs improvement"
            else:
                status = "‚ùå Incomplete"

        print(f"  {pattern.name:40} {status}")

    print(f"\nüí° Use 'czarina patterns contribute' to submit upstream")


def cmd_patterns_contribute():
    """Show contribution guide"""
    orchestrator_dir = get_orchestrator_dir()
    guide = orchestrator_dir / "czarina-core" / "patterns" / "PATTERN_CONTRIBUTION_GUIDE.md"

    if guide.exists():
        with open(guide) as f:
            lines = f.readlines()[:50]
            print("".join(lines))
            if len(lines) >= 50:
                print(f"\nüìñ Read full guide: {guide}")
    else:
        print("üìñ Contribution guide not found")

    print("\nüìù Quick start:")
    print("  1. Document pattern in: czarina-inbox/patterns/")
    print("  2. Check pending: czarina patterns pending")
    print("  3. Follow guide to submit upstream")


def cmd_analyze(plan_file, output_file=None, auto_init=False, interactive=False):
    """
    Analyze implementation plan and suggest orchestration setup

    Uses Claude AI to analyze the plan and generate complete orchestration setup.

    Interactive mode: Works with any AI agent (Claude Code, Cursor, etc.)
    Automated mode: Requires Anthropic API key
    """
    from analyzer import ProjectAnalyzer

    orchestrator_dir = get_orchestrator_dir()

    print("üîç Czarina Project Analysis")
    print("=" * 60)
    print()

    # Check if plan file exists
    plan_path = Path(plan_file)
    if not plan_path.exists():
        print(f"‚ùå Plan file not found: {plan_file}")
        sys.exit(1)

    print(f"üìÑ Input Plan: {plan_file}")
    print()

    # Read plan file
    with open(plan_path) as f:
        plan_content = f.read()

    plan_lines = len(plan_content.split('\n'))
    plan_words = len(plan_content.split())

    print(f"üìä Plan Statistics:")
    print(f"   Lines: {plan_lines}")
    print(f"   Words: {plan_words}")
    print(f"   Characters: {len(plan_content)}")
    print()

    # Create analyzer and run analysis
    try:
        analyzer = ProjectAnalyzer(orchestrator_dir)

        if interactive:
            print("ü§ù Interactive Mode - Works with ANY AI agent!")
            print()
        else:
            print("ü§ñ Automated Mode - Using Claude API...")
            print()

        analysis = analyzer.analyze(plan_content, plan_path, interactive=interactive)

        # Print summary
        analyzer.print_summary(analysis)

        # Save analysis if output file specified
        if output_file:
            analyzer.save_analysis(analysis, output_file)
            print(f"üíæ Analysis saved to: {output_file}")
            print()

        # Auto-initialize project if requested
        if auto_init:
            print("üöÄ Auto-initializing project...")
            print()

            current_dir = Path.cwd()

            # Check if already initialized
            czarina_dir = current_dir / ".czarina"
            if czarina_dir.exists():
                print(f"‚ùå Project already initialized in {current_dir}")
                print(f"   .czarina/ directory exists")
                print()
                print("üí° To re-analyze, delete .czarina/ first or use --output to save analysis only")
                sys.exit(1)

            # Create .czarina/ structure
            czarina_dir.mkdir()
            (czarina_dir / "workers").mkdir()
            (czarina_dir / "status").mkdir()

            # Generate and save config.json
            config = analyzer.generate_config(analysis, current_dir)
            config_file = czarina_dir / "config.json"
            with open(config_file, 'w') as f:
                json.dump(config, f, indent=2)
            print(f"‚úÖ Created: .czarina/config.json")

            # Generate and save worker prompts
            worker_prompts = analyzer.generate_worker_prompts(analysis)
            for worker_id, prompt_content in worker_prompts.items():
                worker_file = czarina_dir / "workers" / f"{worker_id}.md"
                with open(worker_file, 'w') as f:
                    f.write(prompt_content)
                print(f"‚úÖ Created: .czarina/workers/{worker_id}.md")

            # Save complete analysis
            analysis_file = czarina_dir / "analysis.json"
            analyzer.save_analysis(analysis, analysis_file)
            print(f"‚úÖ Created: .czarina/analysis.json")

            # Create .worker-init script
            worker_init = czarina_dir / ".worker-init"
            with open(worker_init, "w") as f:
                f.write(f"""#!/bin/bash
# Czarina Worker Auto-Init
# This script helps workers discover their role and setup

CZARINA_DIR="$(cd "$(dirname "${{BASH_SOURCE[0]}})" && pwd)"
CONFIG_FILE="$CZARINA_DIR/config.json"

if [ ! -f "$CONFIG_FILE" ]; then
    echo "‚ùå Config file not found: $CONFIG_FILE"
    exit 1
fi

# Show available workers
echo "üìã Available workers:"
jq -r '.workers[] | "  ‚Ä¢ \\(.id) - \\(.description)"' "$CONFIG_FILE"
echo ""

# If worker ID provided, load it
if [ -n "$1" ]; then
    WORKER_ID="$1"
    WORKER_FILE="$CZARINA_DIR/workers/$WORKER_ID.md"

    if [ -f "$WORKER_FILE" ]; then
        echo "‚úÖ Loading worker: $WORKER_ID"
        cat "$WORKER_FILE"
    else
        echo "‚ùå Worker file not found: $WORKER_FILE"
        exit 1
    fi
else
    echo "üí° Usage: ./.czarina/.worker-init <worker-id>"
fi
""")
            worker_init.chmod(0o755)
            print(f"‚úÖ Created: .czarina/.worker-init")

            # Create README
            readme = czarina_dir / "README.md"
            project_name = analysis["analysis"]["project_name"]
            with open(readme, "w") as f:
                f.write(f"""# Czarina Orchestration - {project_name}

## Quick Start

### For Workers

**Claude Code / Desktop:**
```bash
./.czarina/.worker-init <worker-id>
```

**Claude Code Web (auto-discovery):**
Just say: "You are <worker-id>"

### For Orchestrators

**Launch all workers:**
```bash
czarina launch
```

**Start daemon (auto-approval):**
```bash
czarina daemon start
```

**Check status:**
```bash
czarina status
```

## Configuration

Edit `.czarina/config.json` to:
- Add/remove workers
- Configure agent types
- Set daemon behavior
- Update token budgets

Edit `.czarina/workers/*.md` to define worker roles and tasks.

## Workers

{chr(10).join(f"- **{w['id']}**: {w['description']}" for w in config['workers'])}

## Version Plan

{chr(10).join(f"- **{v}**: {config['version_plan'][v]['description']} ({config['version_plan'][v]['token_budget']['projected']:,} tokens)" for v in config['version_plan'])}

## Project

**Repository:** {current_dir}
**Orchestration:** .czarina/
**Generated:** {datetime.now().strftime('%Y-%m-%d')}
**From:** {plan_file}
""")
            print(f"‚úÖ Created: .czarina/README.md")

            # Update .gitignore
            gitignore = current_dir / ".gitignore"
            gitignore_content = ""
            if gitignore.exists():
                gitignore_content = gitignore.read_text()

            if ".czarina/status/" not in gitignore_content:
                with open(gitignore, "a") as f:
                    if gitignore_content and not gitignore_content.endswith("\n"):
                        f.write("\n")
                    f.write("\n# Czarina orchestration\n")
                    f.write(".czarina/status/\n")
                print(f"‚úÖ Updated: .gitignore")

            print()
            print("=" * 60)
            print("‚úÖ PROJECT INITIALIZED")
            print("=" * 60)
            print()
            print(f"üìÅ Location: {current_dir}")
            print(f"üìã Project: {project_name}")
            print(f"üë∑ Workers: {len(config['workers'])}")
            print(f"üì¶ Versions: {len(config['version_plan'])}")
            print()
            print("üìù Next steps:")
            print("  1. Review .czarina/config.json")
            print("  2. Review .czarina/workers/*.md")
            print("  3. git add .czarina/")
            print("  4. git commit -m 'Add Czarina orchestration'")
            print("  5. czarina launch")
            print("  6. czarina daemon start")
            print()

        else:
            print()
            print("üí° To initialize project with this analysis:")
            print(f"   czarina analyze {plan_file} --init")
            print()
            print("Or save analysis for later:")
            print(f"   czarina analyze {plan_file} --output analysis.json")
            print()

    except Exception as e:
        print(f"‚ùå Analysis failed: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

    print("=" * 60)


def show_usage():
    """Show usage information"""
    print(__doc__)
    print("\nExamples:")
    print("  # Interactive analysis (works with Claude Code, Cursor, any agent!)")
    print("  czarina analyze implementation-plan.md --interactive --init")
    print("")
    print("  # Automated analysis (requires Anthropic API key)")
    print("  czarina analyze implementation-plan.md --init")
    print("")
    print("  # Analyze and save to file (no init)")
    print("  czarina analyze implementation-plan.md --output analysis.json")
    print("")
    print("  # Manual initialization")
    print("  cd ~/my-project && czarina init")
    print("")
    print("  # Launch from project directory")
    print("  cd ~/my-project && czarina launch")
    print("")
    print("  # Launch from anywhere by name")
    print("  czarina launch my-project")
    print("")
    print("  # Daemon and patterns")
    print("  czarina daemon start")
    print("  czarina patterns update")
    print("  czarina list")


def main():
    if len(sys.argv) < 2:
        show_usage()
        sys.exit(1)

    command = sys.argv[1]

    if command == "analyze":
        if len(sys.argv) < 3:
            print("‚ùå Usage: czarina analyze <plan-file> [--output file.json] [--init] [--interactive]")
            sys.exit(1)
        plan_file = sys.argv[2]
        output_file = None
        auto_init = False
        interactive = False
        # Parse optional flags
        for i in range(3, len(sys.argv)):
            if sys.argv[i] == "--output" and i + 1 < len(sys.argv):
                output_file = sys.argv[i + 1]
            elif sys.argv[i] == "--init":
                auto_init = True
            elif sys.argv[i] == "--interactive":
                interactive = True
        cmd_analyze(plan_file, output_file, auto_init, interactive)
    elif command == "init":
        project_name = sys.argv[2] if len(sys.argv) > 2 else None
        cmd_init(project_name)
    elif command == "list":
        cmd_list()
    elif command == "launch":
        project_name = sys.argv[2] if len(sys.argv) > 2 else None
        cmd_launch(project_name)
    elif command == "status":
        project_name = sys.argv[2] if len(sys.argv) > 2 else None
        cmd_status(project_name)
    elif command == "daemon":
        if len(sys.argv) < 3:
            print("‚ùå Usage: czarina daemon <start|stop|logs|status> [project]")
            sys.exit(1)
        subcommand = sys.argv[2]
        project_name = sys.argv[3] if len(sys.argv) > 3 else None
        if subcommand == "start":
            cmd_daemon_start(project_name)
        elif subcommand == "stop":
            cmd_daemon_stop(project_name)
        elif subcommand == "logs":
            cmd_daemon_logs(project_name)
        elif subcommand == "status":
            cmd_daemon_status(project_name)
        else:
            print(f"‚ùå Unknown daemon subcommand: {subcommand}")
            print("   Valid: start, stop, logs, status")
            sys.exit(1)
    elif command == "patterns":
        if len(sys.argv) < 3:
            print("‚ùå Usage: czarina patterns <update|version|pending|contribute>")
            sys.exit(1)
        subcommand = sys.argv[2]
        if subcommand == "update":
            cmd_patterns_update()
        elif subcommand == "version":
            cmd_patterns_version()
        elif subcommand == "pending":
            cmd_patterns_pending()
        elif subcommand == "contribute":
            cmd_patterns_contribute()
        else:
            print(f"‚ùå Unknown patterns subcommand: {subcommand}")
            print("   Valid: update, version, pending, contribute")
            sys.exit(1)
    elif command in ["-h", "--help", "help"]:
        show_usage()
    else:
        print(f"‚ùå Unknown command: {command}")
        show_usage()
        sys.exit(1)


if __name__ == "__main__":
    main()
