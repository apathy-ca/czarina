#!/usr/bin/env python3
"""
Czarina - Multi-Agent Orchestration CLI
Simple interface for managing multi-agent orchestration projects

Version: 0.4.0

Usage:
    czarina analyze <plan-file>                  - Analyze plan and suggest orchestration
    czarina analyze <plan-file> --interactive    - Interactive mode (works with any AI agent!)
    czarina analyze <plan-file> --init           - Analyze and initialize project
    czarina analyze <plan-file> --output file    - Save analysis to file
    czarina init [project-name]                  - Initialize orchestration in current dir
    czarina init --from-config <config.json>     - Initialize from pre-made config file
    czarina init --from-config <file> --force    - Re-initialize (replaces existing)
    czarina list                                 - List all Czarina projects
    czarina launch [project]                     - Launch project workers
    czarina status [project]                     - Show project status
    czarina dashboard [project]                  - Live monitoring dashboard
    czarina phase close [project]                - Close current phase, keep project for next phase
    czarina closeout [project]                   - Stop all workers and clean up completely
    czarina daemon start [project]               - Start autonomous daemon
    czarina daemon stop [project]                - Stop daemon
    czarina daemon logs [project]                - Show daemon logs
    czarina daemon status [project]              - Check daemon status
    czarina patterns update                      - Update pattern library
    czarina patterns version                     - Show pattern version
    czarina patterns pending                     - List patterns ready to contribute
    czarina patterns contribute                  - Show contribution guide
    czarina version                              - Show version information
"""

CZARINA_VERSION = "0.5.0"

import sys
import subprocess
import json
import os
from pathlib import Path
from datetime import datetime

# Add czarina-core to path for imports
# Resolve symlinks to find the actual repository location
sys.path.insert(0, str(Path(__file__).resolve().parent / "czarina-core"))


def get_orchestrator_dir():
    """Get the orchestrator root directory"""
    return Path(__file__).resolve().parent


def find_czarina_dir(start_path=None):
    """
    Find .czarina/ directory by searching up from start_path
    Returns (czarina_dir, project_root) or (None, None)
    """
    if start_path is None:
        start_path = Path.cwd()
    else:
        start_path = Path(start_path).resolve()

    current = start_path
    while current != current.parent:
        czarina_dir = current / ".czarina"
        if czarina_dir.exists() and czarina_dir.is_dir():
            return czarina_dir, current
        current = current.parent

    return None, None


def find_project_by_name(project_name):
    """
    Search for a project by name in common locations
    Returns (czarina_dir, project_root) or (None, None)
    """
    # Search in home directory projects
    home = Path.home()
    search_paths = [
        home / "projects",
        home / "Source",
        home / "Source" / "GRID",
        home / "code",
        home / "dev",
    ]

    for base in search_paths:
        if not base.exists():
            continue
        for item in base.rglob(".czarina"):
            if item.is_dir():
                config_file = item / "config.json"
                if config_file.exists():
                    try:
                        with open(config_file) as f:
                            config = json.load(f)
                            if config.get("project", {}).get("slug") == project_name:
                                return item, item.parent
                    except:
                        pass

    return None, None


def get_project_context(project_name=None):
    """
    Get project context (czarina_dir and project_root)

    Priority:
    1. If project_name given, search for it
    2. Look for .czarina/ in current directory or parents
    3. Fail with helpful message
    """
    if project_name:
        czarina_dir, project_root = find_project_by_name(project_name)
        if czarina_dir:
            return czarina_dir, project_root
        print(f"‚ùå Project '{project_name}' not found")
        print(f"üí° Run 'czarina list' to see available projects")
        sys.exit(1)

    # Try current directory
    czarina_dir, project_root = find_czarina_dir()
    if czarina_dir:
        return czarina_dir, project_root

    print("‚ùå No Czarina project found")
    print("üí° Run 'czarina init' in your project directory")
    print("üí° Or specify project name: 'czarina launch <project>'")
    sys.exit(1)


def _create_czarina_readme(czarina_dir, config):
    """Helper to create README.md for .czarina directory"""
    readme = czarina_dir / "README.md"
    project_name = config["project"]["name"]
    workers = config["workers"]
    worker_list = "\n".join([f"- **{w['id']}**: {w.get('description', 'Worker')}"
                             for w in workers])

    with open(readme, "w") as f:
        f.write(f"""# Czarina Orchestration - {project_name}

## Quick Start

### For Workers

**Claude Code / Desktop:**
```bash
./.czarina/.worker-init <worker-id>
```

**Claude Code Web (auto-discovery):**
Just say: "You are <worker-id>"

### For Orchestrators

**Launch all workers:**
```bash
czarina launch
```

**Start daemon (auto-approval):**
```bash
czarina daemon start
```

**Check status:**
```bash
czarina status
```

## Configuration

Edit `.czarina/config.json` to:
- Add/remove workers
- Configure agent types
- Set daemon behavior

Edit `.czarina/workers/*.md` to define worker roles and tasks.

## Workers

{worker_list}

## Project

**Repository:** {config['project']['repository']}
**Orchestration:** .czarina/

Created: {datetime.now().strftime('%Y-%m-%d')}
""")


def cmd_init_from_config(config_file_path, current_dir, czarina_dir):
    """Initialize from a pre-made configuration file"""
    config_path = Path(config_file_path)

    if not config_path.exists():
        print(f"‚ùå Config file not found: {config_file_path}")
        sys.exit(1)

    print(f"üìÑ Loading configuration from: {config_file_path}")
    print()

    # Load the user's config
    with open(config_path) as f:
        user_config = json.load(f)

    # Create .czarina/ structure (may already exist from phase close)
    czarina_dir.mkdir(exist_ok=True)
    (czarina_dir / "workers").mkdir(exist_ok=True)
    (czarina_dir / "status").mkdir(exist_ok=True)

    # Convert user format to czarina format
    workers_dict = user_config.get("workers", {})
    workers_list = []

    for worker_id, worker_data in workers_dict.items():
        workers_list.append({
            "id": worker_id,
            "agent": worker_data.get("agent", "aider"),
            "branch": worker_data.get("branch", f"feat/{worker_id}"),
            "description": worker_data.get("name", worker_data.get("role", f"Worker {worker_id}"))
        })

    # Build czarina config
    czarina_config = {
        "project": {
            "name": user_config.get("project", current_dir.name),
            "slug": user_config.get("project", current_dir.name).lower().replace(" ", "-"),
            "repository": str(current_dir),
            "orchestration_dir": ".czarina",
            "version": user_config.get("version", "1.0.0"),
            "phase": user_config.get("phase", "default"),
            "description": user_config.get("description", "")
        },
        "workers": workers_list,
        "daemon": user_config.get("daemon", {
            "enabled": True,
            "auto_approve": ["read", "write", "commit"]
        })
    }

    # Save czarina config
    config_file = czarina_dir / "config.json"
    with open(config_file, 'w') as f:
        json.dump(czarina_config, f, indent=2)
    print(f"‚úÖ Created: .czarina/config.json")

    # Generate worker prompts from user config
    for worker_id, worker_data in workers_dict.items():
        worker_file = czarina_dir / "workers" / f"{worker_id}.md"

        # Build worker prompt from user's data
        tasks_section = ""
        if "tasks" in worker_data:
            tasks_section = "\n## Tasks\n\n" + "\n".join([f"- {task}" for task in worker_data["tasks"]])

        files_section = ""
        if "files" in worker_data:
            files_section = "\n## Files\n\n" + "\n".join([f"- `{f}`" for f in worker_data["files"]])

        criteria_section = ""
        if "completion_criteria" in worker_data:
            criteria_section = "\n## Completion Criteria\n\n" + "\n".join([f"- [ ] {c}" for c in worker_data["completion_criteria"]])

        budget = worker_data.get("budget", {})
        token_budget = budget.get("tokens_projected", budget.get("tokens_max", "N/A"))

        with open(worker_file, 'w') as f:
            f.write(f"""# {worker_data.get('name', worker_id)}

## Role
{worker_data.get('role', 'Worker for this project')}

## Branch
{worker_data.get('branch', f'feat/{worker_id}')}

## Token Budget
{token_budget:,} tokens (max: {budget.get('tokens_max', 'N/A')})
{tasks_section}{files_section}{criteria_section}

## Dependencies
{', '.join(worker_data.get('dependencies', [])) or 'None'}

## Git Workflow
When your work is complete:
1. Commit your changes
2. Push to your branch
3. Create a PR to main
4. Update token metrics in status

## Pattern Library
Review before starting:
- czarina-core/patterns/ERROR_RECOVERY_PATTERNS.md
- czarina-core/patterns/CZARINA_PATTERNS.md
""")
        print(f"‚úÖ Created: .czarina/workers/{worker_id}.md")

    # Create CZAR.md
    worker_list = "\n".join([f"- **{w['id']}**: {w.get('description', 'Worker')}"
                             for w in workers_list])
    czar_file = czarina_dir / "workers" / "CZAR.md"
    with open(czar_file, 'w') as f:
        f.write(f"""# Czar - Orchestration Coordinator

## Your Role

You are the **Czar** - the orchestration coordinator for this multi-agent project.

**Project:** {czarina_config['project']['name']}
**Version:** {czarina_config['project']['version']}
**Phase:** {czarina_config['project']['phase']}
**Workers:** {len(workers_list)}

{czarina_config['project']['description']}

## Workers

{worker_list}

## Quick Commands

### Tmux Navigation
- Switch windows: Ctrl+b <number>
- List windows: Ctrl+b w
- Detach: Ctrl+b d

### Git Operations
- Check worktrees: `git worktree list`
- Check branches: `git branch -a`

### Czarina Commands
- Status: `czarina status`
- Dashboard: `czarina dashboard`
- Phase close: `czarina phase close`

## Responsibilities

1. Monitor worker progress
2. Coordinate dependencies
3. Review PRs and manage merges
4. Track project health

‚úÖ Ready to orchestrate!
""")
    print(f"‚úÖ Created: .czarina/workers/CZAR.md")

    # Create README
    _create_czarina_readme(czarina_dir, czarina_config)
    print(f"‚úÖ Created: .czarina/README.md")

    print()
    print("üéâ Czarina initialized successfully!")
    print()
    print(f"üìÅ Created in: {current_dir}")
    print(f"üìã Project: {czarina_config['project']['name']} ({czarina_config['project']['slug']})")
    print()
    print("üìù Next steps:")
    print("  1. Review and edit .czarina/workers/*.md files")
    print("  2. czarina launch")


def cmd_init(project_name=None, from_config=None, force=False):
    """Initialize Czarina orchestration in current directory"""
    current_dir = Path.cwd()

    # Check if already initialized
    czarina_dir = current_dir / ".czarina"
    config_file = czarina_dir / "config.json"
    workers_dir = czarina_dir / "workers"

    if czarina_dir.exists() and config_file.exists():
        # Check if this is an active project or a phase-closed structure
        import shutil

        # If workers directory is empty or doesn't exist, assume phase was closed
        workers_exist = workers_dir.exists() and any(workers_dir.iterdir())

        if workers_exist and not force:
            print(f"‚ùå Czarina already initialized in {current_dir}")
            print(f"   .czarina/ directory exists with active workers")
            print()
            print("üí° Options:")
            print("   1. Close current phase first: czarina phase close")
            print("   2. Force re-initialize: czarina init --from-config <file> --force")
            sys.exit(1)

        if force or not workers_exist:
            if force:
                print(f"‚ö†Ô∏è  Reinitializing (--force): {current_dir}")
            else:
                print(f"üì¶ Initializing new phase in existing project")

            print(f"   Archiving previous phase...")

            # Archive existing config/workers to phases
            phases_dir = czarina_dir / "phases"
            phases_dir.mkdir(exist_ok=True)
            backup_name = f"phase-{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}-reInit"
            backup_dir = phases_dir / backup_name
            backup_dir.mkdir()

            if config_file.exists():
                shutil.copy(config_file, backup_dir / "config.json")
            if workers_dir.exists() and any(workers_dir.iterdir()):
                shutil.copytree(workers_dir, backup_dir / "workers")

            print(f"   ‚úÖ Backed up to: .czarina/phases/{backup_name}")

            # Remove old config and workers (keep phases, archive, status dirs)
            if config_file.exists():
                config_file.unlink()
            if workers_dir.exists():
                shutil.rmtree(workers_dir)

    # Handle --from-config (user provides pre-made config)
    if from_config:
        return cmd_init_from_config(from_config, current_dir, czarina_dir)

    # Detect project name from directory or use provided
    if not project_name:
        project_name = current_dir.name

    # Create slug: lowercase, replace spaces/underscores with single dash, remove special chars
    import re
    slug = project_name.lower()
    slug = re.sub(r'[_\s]+', '-', slug)  # Replace spaces/underscores with single dash
    slug = re.sub(r'[^a-z0-9\-]', '', slug)  # Remove non-alphanumeric except dash
    slug = re.sub(r'-+', '-', slug)  # Collapse multiple dashes
    slug = slug.strip('-')  # Remove leading/trailing dashes

    # Create .czarina/ structure
    czarina_dir.mkdir()
    (czarina_dir / "workers").mkdir()
    (czarina_dir / "status").mkdir()

    # Create config.json
    config = {
        "project": {
            "name": project_name,
            "slug": slug,
            "repository": str(current_dir),
            "orchestration_dir": ".czarina"
        },
        "workers": [
            {
                "id": "worker1",
                "agent": "aider",
                "branch": f"feat/{slug}-worker1",
                "description": "Worker 1"
            }
        ],
        "daemon": {
            "enabled": True,
            "auto_approve": ["read", "write", "commit"]
        }
    }

    config_file = czarina_dir / "config.json"
    with open(config_file, "w") as f:
        json.dump(config, f, indent=2)

    # Create example worker prompt
    worker_file = czarina_dir / "workers" / "worker1.md"
    with open(worker_file, "w") as f:
        f.write(f"""# Worker 1 - {project_name}

## Role
[Describe this worker's role]

## Responsibilities
- [Responsibility 1]
- [Responsibility 2]

## Files
- [Files this worker should work on]

## Git Workflow
Branch: feat/{slug}-worker1

When your work is complete:
1. Commit your changes
2. Push to your branch
3. Create a PR to main
4. Wait for review

## Pattern Library
Before starting, review:
- czarina-core/patterns/ERROR_RECOVERY_PATTERNS.md
- czarina-core/patterns/CZARINA_PATTERNS.md
""")

    # Create .worker-init script for auto-discovery
    worker_init = czarina_dir / ".worker-init"
    orchestrator_dir = get_orchestrator_dir()
    with open(worker_init, "w") as f:
        f.write(f"""#!/bin/bash
# Czarina Worker Auto-Init
# This script helps workers discover their role and setup

CZARINA_DIR="$(cd "$(dirname "${{BASH_SOURCE[0]}}")" && pwd)"
CONFIG_FILE="$CZARINA_DIR/config.json"

if [ ! -f "$CONFIG_FILE" ]; then
    echo "‚ùå Config file not found: $CONFIG_FILE"
    exit 1
fi

# Show available workers
echo "üìã Available workers:"
jq -r '.workers[] | "  ‚Ä¢ \\(.id) - \\(.description)"' "$CONFIG_FILE"
echo ""

# If worker ID provided, load it
if [ -n "$1" ]; then
    WORKER_ID="$1"
    WORKER_FILE="$CZARINA_DIR/workers/$WORKER_ID.md"

    if [ -f "$WORKER_FILE" ]; then
        echo "‚úÖ Loading worker: $WORKER_ID"
        cat "$WORKER_FILE"
    else
        echo "‚ùå Worker file not found: $WORKER_FILE"
        exit 1
    fi
else
    echo "üí° Usage: ./.czarina/.worker-init <worker-id>"
fi
""")
    worker_init.chmod(0o755)

    # Create README
    readme = czarina_dir / "README.md"
    with open(readme, "w") as f:
        f.write(f"""# Czarina Orchestration - {project_name}

## Quick Start

### For Workers

**Claude Code / Desktop:**
```bash
./.czarina/.worker-init worker1
```

**Claude Code Web (auto-discovery):**
Just say: "You are worker1"

### For Orchestrators

**Launch all workers:**
```bash
czarina launch
```

**Start daemon (auto-approval):**
```bash
czarina daemon start
```

**Check status:**
```bash
czarina status
```

## Configuration

Edit `.czarina/config.json` to:
- Add/remove workers
- Configure agent types
- Set daemon behavior

Edit `.czarina/workers/*.md` to define worker roles and tasks.

## Workers

{chr(10).join(f"- **{w['id']}**: {w['description']}" for w in config['workers'])}

## Project

**Repository:** {current_dir}
**Orchestration:** .czarina/

Created: {datetime.now().strftime('%Y-%m-%d')}
""")

    # Update .gitignore
    gitignore = current_dir / ".gitignore"
    gitignore_content = ""
    if gitignore.exists():
        gitignore_content = gitignore.read_text()

    if ".czarina/status/" not in gitignore_content:
        with open(gitignore, "a") as f:
            if gitignore_content and not gitignore_content.endswith("\n"):
                f.write("\n")
            f.write("\n# Czarina orchestration\n")
            f.write(".czarina/status/\n")
            f.write(".czarina/worktrees/\n")

    # Copy branch loader script
    import shutil
    loader_template = orchestrator_dir / "czarina-core" / "templates" / "embedded-orchestration" / "load-worker-by-branch.sh"
    loader_dest = czarina_dir / "load-worker-by-branch.sh"
    if loader_template.exists():
        shutil.copy(loader_template, loader_dest)
        loader_dest.chmod(0o755)

    # Initialize git branches if this is a git repo
    if (current_dir / ".git").exists():
        print("\nüåø Initializing git branches...")
        init_branches_script = orchestrator_dir / "czarina-core" / "init-embedded-branches.sh"
        if init_branches_script.exists():
            result = subprocess.run(
                ["bash", str(init_branches_script), str(current_dir)],
                input="n\n",  # Auto-answer "no" to pull prompt
                text=True,
                capture_output=True
            )
            if result.returncode == 0:
                print("‚úÖ Git branches initialized")

    print("\n‚úÖ Czarina initialized successfully!")
    print(f"\nüìÅ Created in: {current_dir}")
    print(f"üìã Project: {project_name} ({slug})")
    print(f"\nüìù Next steps:")
    print(f"  1. Edit .czarina/config.json - configure workers")
    print(f"  2. Edit .czarina/workers/*.md - define worker roles")
    print(f"  3. (Optional) Setup .claude/settings.local.json SessionStart hook")
    print(f"     See: {orchestrator_dir}/docs/BRANCH_BASED_WORKER_LOADING.md")
    print(f"  4. git add .czarina/")
    print(f"  5. git commit -m 'Add Czarina orchestration'")
    print(f"  6. czarina launch  (will auto-create branches if needed)")
    print(f"\nüí° Read more: {orchestrator_dir}/docs/BRANCH_BASED_WORKER_LOADING.md")


def cmd_list():
    """List all Czarina projects"""
    home = Path.home()
    search_paths = [
        home / "projects",
        home / "Source",
        home / "Source" / "GRID",
        home / "code",
        home / "dev",
    ]

    projects = []
    for base in search_paths:
        if not base.exists():
            continue
        for item in base.rglob(".czarina"):
            if item.is_dir():
                config_file = item / "config.json"
                if config_file.exists():
                    try:
                        with open(config_file) as f:
                            config = json.load(f)
                            projects.append({
                                "name": config.get("project", {}).get("name", "Unknown"),
                                "slug": config.get("project", {}).get("slug", "unknown"),
                                "path": item.parent,
                                "workers": len(config.get("workers", []))
                            })
                    except:
                        pass

    if not projects:
        print("üìã No Czarina projects found")
        print("üí° Run 'czarina init' in a project directory to create one")
        return

    print("üìã Czarina Projects:\n")
    for p in sorted(projects, key=lambda x: x["name"]):
        print(f"  ‚Ä¢ {p['name']} ({p['slug']})")
        print(f"    Path: {p['path']}")
        print(f"    Workers: {p['workers']}")
        print()


def cmd_launch(project_name=None):
    """Launch workers for project"""
    czarina_dir, project_root = get_project_context(project_name)

    # Load config
    config_file = czarina_dir / "config.json"
    with open(config_file) as f:
        config = json.load(f)

    project_slug = config["project"]["slug"]
    workers = config["workers"]

    print(f"üöÄ Launching: {config['project']['name']}")
    print(f"   Workers: {len(workers)}")
    print(f"   Project: {project_root}")
    print()

    # Check if git branches exist, initialize if needed
    orchestrator_dir = get_orchestrator_dir()
    if (project_root / ".git").exists():
        # Check if any worker branches are missing
        branches_missing = False
        for worker in workers:
            branch = worker.get("branch", "")
            if branch:
                result = subprocess.run(
                    ["git", "-C", str(project_root), "show-ref", "--verify", "--quiet", f"refs/heads/{branch}"],
                    capture_output=True
                )
                if result.returncode != 0:
                    branches_missing = True
                    break

        if branches_missing:
            print("üåø Some worker branches don't exist yet. Initializing...")
            init_branches_script = orchestrator_dir / "czarina-core" / "init-embedded-branches.sh"
            if init_branches_script.exists():
                result = subprocess.run(
                    ["bash", str(init_branches_script), str(project_root)],
                    input="n\n",  # Auto-answer "no" to pull prompt
                    text=True
                )
                if result.returncode == 0:
                    print("‚úÖ Git branches initialized")
                else:
                    print("‚ö†Ô∏è  Branch initialization had issues, continuing anyway...")
            print()

    # Use orchestrator launch script (v2 with improved UX)
    launch_script_v2 = orchestrator_dir / "czarina-core" / "launch-project-v2.sh"
    launch_script_v1 = orchestrator_dir / "czarina-core" / "launch-project.sh"

    # Prefer v2 if it exists
    if launch_script_v2.exists():
        launch_script = launch_script_v2
    elif launch_script_v1.exists():
        launch_script = launch_script_v1
    else:
        print(f"‚ùå Launch script not found")
        sys.exit(1)

    # Launch via embedded orchestration launcher
    os.chdir(project_root)
    subprocess.run(["bash", str(launch_script), str(czarina_dir)])


def cmd_status(project_name=None):
    """Show project status"""
    czarina_dir, project_root = get_project_context(project_name)

    config_file = czarina_dir / "config.json"
    with open(config_file) as f:
        config = json.load(f)

    print(f"üìä Status: {config['project']['name']}")
    print(f"   Location: {project_root}")
    print(f"   Workers: {len(config['workers'])}")
    print()

    # Check tmux session
    session_name = f"czarina-{config['project']['slug']}"
    result = subprocess.run(
        ["tmux", "has-session", "-t", session_name],
        capture_output=True
    )

    if result.returncode == 0:
        print(f"   Session: ‚úÖ Running ({session_name})")
        print(f"   Attach: tmux attach -t {session_name}")
    else:
        print(f"   Session: ‚ùå Not running")
        print(f"   Start: czarina launch")


def cmd_dashboard(project_name=None):
    """Launch live monitoring dashboard"""
    czarina_dir, project_root = get_project_context(project_name)
    orchestrator_dir = get_orchestrator_dir()
    dashboard_script = orchestrator_dir / "czarina-core" / "dashboard-v2.py"

    if not dashboard_script.exists():
        print(f"‚ùå Dashboard script not found: {dashboard_script}")
        sys.exit(1)

    print("üé≠ Launching dashboard...")
    print("   Press Ctrl+C to exit")
    print()

    os.chdir(project_root)
    subprocess.run([sys.executable, str(dashboard_script)])


def cmd_phase_close(project_name=None):
    """Close current phase but keep project structure for next phase"""
    czarina_dir, project_root = get_project_context(project_name)
    orchestrator_dir = get_orchestrator_dir()
    phase_close_script = orchestrator_dir / "czarina-core" / "phase-close.sh"

    if not phase_close_script.exists():
        print(f"‚ùå Phase close script not found: {phase_close_script}")
        sys.exit(1)

    os.chdir(project_root)
    subprocess.run(["bash", str(phase_close_script), str(czarina_dir)])


def cmd_closeout(project_name=None):
    """Stop all workers, archive logs, and clean up worktrees"""
    czarina_dir, project_root = get_project_context(project_name)
    orchestrator_dir = get_orchestrator_dir()
    closeout_script = orchestrator_dir / "czarina-core" / "closeout-project.sh"

    if not closeout_script.exists():
        print(f"‚ùå Closeout script not found: {closeout_script}")
        sys.exit(1)

    os.chdir(project_root)
    subprocess.run(["bash", str(closeout_script), str(czarina_dir)])


def cmd_daemon_start(project_name=None):
    """Start autonomous daemon for project"""
    czarina_dir, project_root = get_project_context(project_name)
    orchestrator_dir = get_orchestrator_dir()
    daemon_script = orchestrator_dir / "czarina-core" / "daemon" / "start-daemon.sh"

    print("‚ö° Starting daemon...")
    subprocess.run(["bash", str(daemon_script), str(czarina_dir)])


def cmd_daemon_stop(project_name=None):
    """Stop daemon for project"""
    czarina_dir, project_root = get_project_context(project_name)

    config_file = czarina_dir / "config.json"
    with open(config_file) as f:
        config = json.load(f)

    daemon_session = f"{config['project']['slug']}-daemon"
    subprocess.run(["tmux", "kill-session", "-t", daemon_session])
    print(f"‚ö° Daemon stopped")


def cmd_daemon_logs(project_name=None):
    """Show daemon logs for project"""
    czarina_dir, project_root = get_project_context(project_name)
    log_file = czarina_dir / "status" / "daemon.log"

    if log_file.exists():
        subprocess.run(["tail", "-f", str(log_file)])
    else:
        print(f"‚ùå No daemon logs found: {log_file}")


def cmd_daemon_status(project_name=None):
    """Check if daemon is running for project"""
    czarina_dir, project_root = get_project_context(project_name)

    config_file = czarina_dir / "config.json"
    with open(config_file) as f:
        config = json.load(f)

    daemon_session = f"{config['project']['slug']}-daemon"
    result = subprocess.run(
        ["tmux", "has-session", "-t", daemon_session],
        capture_output=True
    )

    if result.returncode == 0:
        print(f"‚ö° Daemon: ‚úÖ Running")
    else:
        print(f"‚ö° Daemon: ‚ùå Not running")
        print(f"   Start: czarina daemon start")


def cmd_patterns_update():
    """Update development patterns from upstream"""
    orchestrator_dir = get_orchestrator_dir()
    script_path = orchestrator_dir / "czarina-core" / "patterns" / "update-patterns.sh"
    subprocess.run(["bash", str(script_path)])


def cmd_patterns_version():
    """Show current pattern version"""
    orchestrator_dir = get_orchestrator_dir()
    version_file = orchestrator_dir / "czarina-core" / "patterns" / ".pattern-version"
    if version_file.exists():
        with open(version_file) as f:
            lines = f.readlines()
            version = lines[0].strip()
            if len(lines) > 1:
                updated = lines[1].strip()
                print(f"üìö Pattern version: {version}")
                print(f"üìÖ Last updated: {updated}")
            else:
                print(f"üìö Pattern version: {version}")
    else:
        print("üìö Patterns not yet downloaded")
        print("üí° Run: czarina patterns update")


def cmd_patterns_pending():
    """List patterns ready to contribute upstream"""
    orchestrator_dir = get_orchestrator_dir()
    inbox_patterns = orchestrator_dir / "czarina-inbox" / "patterns"

    if not inbox_patterns.exists():
        inbox_patterns.mkdir(parents=True)

    patterns = list(inbox_patterns.glob("*.md"))

    if not patterns:
        print("üìù No patterns pending contribution")
        print("üí° Document patterns in: czarina-inbox/patterns/")
        return

    print("üìù Patterns ready to contribute:\n")
    for pattern in sorted(patterns):
        with open(pattern) as f:
            content = f.read()
            has_example = "```" in content or "Example" in content
            has_metrics = any(word in content for word in ["Value:", "%", "reduction", "improvement"])

            if has_example and has_metrics:
                status = "‚úÖ Ready"
            elif has_example or has_metrics:
                status = "‚ö†Ô∏è  Needs improvement"
            else:
                status = "‚ùå Incomplete"

        print(f"  {pattern.name:40} {status}")

    print(f"\nüí° Use 'czarina patterns contribute' to submit upstream")


def cmd_patterns_contribute():
    """Show contribution guide"""
    orchestrator_dir = get_orchestrator_dir()
    guide = orchestrator_dir / "czarina-core" / "patterns" / "PATTERN_CONTRIBUTION_GUIDE.md"

    if guide.exists():
        with open(guide) as f:
            lines = f.readlines()[:50]
            print("".join(lines))
            if len(lines) >= 50:
                print(f"\nüìñ Read full guide: {guide}")
    else:
        print("üìñ Contribution guide not found")

    print("\nüìù Quick start:")
    print("  1. Document pattern in: czarina-inbox/patterns/")
    print("  2. Check pending: czarina patterns pending")
    print("  3. Follow guide to submit upstream")


def cmd_analyze(plan_file, output_file=None, auto_init=False, interactive=False):
    """
    Analyze implementation plan and suggest orchestration setup

    Uses Claude AI to analyze the plan and generate complete orchestration setup.

    Interactive mode: Works with any AI agent (Claude Code, Cursor, etc.)
    Automated mode: Requires Anthropic API key
    """
    from analyzer import ProjectAnalyzer

    orchestrator_dir = get_orchestrator_dir()

    print("üîç Czarina Project Analysis")
    print("=" * 60)
    print()

    # Check if plan file exists
    plan_path = Path(plan_file)
    if not plan_path.exists():
        print(f"‚ùå Plan file not found: {plan_file}")
        sys.exit(1)

    print(f"üìÑ Input Plan: {plan_file}")
    print()

    # Read plan file
    with open(plan_path) as f:
        plan_content = f.read()

    plan_lines = len(plan_content.split('\n'))
    plan_words = len(plan_content.split())

    print(f"üìä Plan Statistics:")
    print(f"   Lines: {plan_lines}")
    print(f"   Words: {plan_words}")
    print(f"   Characters: {len(plan_content)}")
    print()

    # Create analyzer and run analysis
    try:
        analyzer = ProjectAnalyzer(orchestrator_dir)

        if interactive:
            print("ü§ù Interactive Mode - Works with ANY AI agent!")
            print()
        else:
            print("ü§ñ Automated Mode - Using Claude API...")
            print()

        analysis = analyzer.analyze(plan_content, plan_path, interactive=interactive)

        # Print summary
        analyzer.print_summary(analysis)

        # Save analysis if output file specified
        if output_file:
            analyzer.save_analysis(analysis, output_file)
            print(f"üíæ Analysis saved to: {output_file}")
            print()

        # Auto-initialize project if requested
        if auto_init:
            print("üöÄ Auto-initializing project...")
            print()

            current_dir = Path.cwd()

            # Check if already initialized
            czarina_dir = current_dir / ".czarina"
            if czarina_dir.exists():
                print(f"‚ùå Project already initialized in {current_dir}")
                print(f"   .czarina/ directory exists")
                print()
                print("üí° To re-analyze, delete .czarina/ first or use --output to save analysis only")
                sys.exit(1)

            # Create .czarina/ structure
            czarina_dir.mkdir()
            (czarina_dir / "workers").mkdir()
            (czarina_dir / "status").mkdir()

            # Generate and save config.json
            config = analyzer.generate_config(analysis, current_dir)
            config_file = czarina_dir / "config.json"
            with open(config_file, 'w') as f:
                json.dump(config, f, indent=2)
            print(f"‚úÖ Created: .czarina/config.json")

            # Generate and save worker prompts
            worker_prompts = analyzer.generate_worker_prompts(analysis)
            for worker_id, prompt_content in worker_prompts.items():
                worker_file = czarina_dir / "workers" / f"{worker_id}.md"
                with open(worker_file, 'w') as f:
                    f.write(prompt_content)
                print(f"‚úÖ Created: .czarina/workers/{worker_id}.md")

            # Create CZAR.md (orchestrator instructions)
            czar_file = czarina_dir / "workers" / "CZAR.md"
            worker_count = len(config["workers"])
            worker_list = "\n".join([f"- **{w['id']}**: {w.get('description', 'Worker')}"
                                     for w in config["workers"]])
            with open(czar_file, 'w') as f:
                f.write(f"""# Czar - Orchestration Coordinator

## Your Role

You are the **Czar** - the orchestration coordinator for this multi-agent project.

**Project:** {config['project']['name']}
**Workers:** {worker_count}
**Your Window:** tmux window 0 (czar)

## Responsibilities

### 1. Monitor Worker Progress
- Track completion of worker tasks
- Identify blockers and dependencies
- Coordinate handoffs between workers

### 2. Manage Integration
- Review PRs from workers as they complete
- Coordinate merges when dependencies are met
- Ensure integration tests pass

### 3. Track Project Health
- Monitor test coverage and quality
- Watch for conflicts or duplicate work
- Keep project documentation updated

### 4. Coordinate Communication
- Facilitate cross-worker discussions
- Escalate issues that need user input
- Document decisions and changes

## Workers

{worker_list}

## Quick Commands

### Tmux Navigation
```bash
# Switch to worker windows
Ctrl+b 1    # Worker 1
Ctrl+b 2    # Worker 2
# ... etc

# List all windows
Ctrl+b w

# Switch sessions (for >9 workers)
Ctrl+b s

# Detach from session
Ctrl+b d
```

### Git Operations
```bash
# Check all worker branches
git branch -a

# Check worktrees
git worktree list

# View worker's changes
git log <worker-branch> --oneline

# Check for conflicts
git diff main...<worker-branch>
```

### Czarina Commands
```bash
# Check project status
czarina status

# View dashboard (if available)
czarina dashboard

# Check daemon status
czarina daemon status

# View daemon logs
czarina daemon logs
```

## Workflow

1. **Launch Phase**
   - All workers start in their isolated worktrees
   - Each has their instructions in `.czarina/workers/<worker-id>.md`
   - Monitor tmux windows to see progress

2. **Development Phase**
   - Workers implement their assigned features
   - You track progress and coordinate
   - Help resolve blockers or conflicts

3. **Integration Phase**
   - Workers create PRs as they complete
   - You review and coordinate merges
   - Watch for dependency ordering

4. **Completion Phase**
   - Verify all features integrated
   - Run full test suite
   - Update project documentation
   - Prepare release notes

## Tips

- **Be proactive**: Check in on workers periodically
- **Document decisions**: Keep notes on what's been decided
- **Watch dependencies**: Some workers may need others to finish first
- **Communicate clearly**: Make sure workers know about changes affecting them
- **Stay organized**: Use this window to track TODOs and status

## Status Tracking

You can track worker status here:

```markdown
## Worker Status

- [ ] {config['workers'][0]['id']} - {config['workers'][0].get('description', 'In progress')}
{''.join([f"- [ ] {w['id']} - {w.get('description', 'In progress')}" + chr(10) for w in config['workers'][1:]])}
```

Update this as workers complete their tasks!

---

**Remember:** You're the coordinator, not a micromanager. Trust your workers to do their jobs, but be ready to help when needed.

‚úÖ Ready to orchestrate!
""")
            print(f"‚úÖ Created: .czarina/workers/CZAR.md")

            # Save complete analysis
            analysis_file = czarina_dir / "analysis.json"
            analyzer.save_analysis(analysis, analysis_file)
            print(f"‚úÖ Created: .czarina/analysis.json")

            # Create .worker-init script
            worker_init = czarina_dir / ".worker-init"
            with open(worker_init, "w") as f:
                f.write(f"""#!/bin/bash
# Czarina Worker Auto-Init
# This script helps workers discover their role and setup

CZARINA_DIR="$(cd "$(dirname "${{BASH_SOURCE[0]}})" && pwd)"
CONFIG_FILE="$CZARINA_DIR/config.json"

if [ ! -f "$CONFIG_FILE" ]; then
    echo "‚ùå Config file not found: $CONFIG_FILE"
    exit 1
fi

# Show available workers
echo "üìã Available workers:"
jq -r '.workers[] | "  ‚Ä¢ \\(.id) - \\(.description)"' "$CONFIG_FILE"
echo ""

# If worker ID provided, load it
if [ -n "$1" ]; then
    WORKER_ID="$1"
    WORKER_FILE="$CZARINA_DIR/workers/$WORKER_ID.md"

    if [ -f "$WORKER_FILE" ]; then
        echo "‚úÖ Loading worker: $WORKER_ID"
        cat "$WORKER_FILE"
    else
        echo "‚ùå Worker file not found: $WORKER_FILE"
        exit 1
    fi
else
    echo "üí° Usage: ./.czarina/.worker-init <worker-id>"
fi
""")
            worker_init.chmod(0o755)
            print(f"‚úÖ Created: .czarina/.worker-init")

            # Create README
            readme = czarina_dir / "README.md"
            project_name = analysis["analysis"]["project_name"]
            with open(readme, "w") as f:
                f.write(f"""# Czarina Orchestration - {project_name}

## Quick Start

### For Workers

**Claude Code / Desktop:**
```bash
./.czarina/.worker-init <worker-id>
```

**Claude Code Web (auto-discovery):**
Just say: "You are <worker-id>"

### For Orchestrators

**Launch all workers:**
```bash
czarina launch
```

**Start daemon (auto-approval):**
```bash
czarina daemon start
```

**Check status:**
```bash
czarina status
```

## Configuration

Edit `.czarina/config.json` to:
- Add/remove workers
- Configure agent types
- Set daemon behavior
- Update token budgets

Edit `.czarina/workers/*.md` to define worker roles and tasks.

## Workers

{chr(10).join(f"- **{w['id']}**: {w['description']}" for w in config['workers'])}

## Version Plan

{chr(10).join(f"- **{v}**: {config['version_plan'][v]['description']} ({config['version_plan'][v]['token_budget']['projected']:,} tokens)" for v in config['version_plan'])}

## Project

**Repository:** {current_dir}
**Orchestration:** .czarina/
**Generated:** {datetime.now().strftime('%Y-%m-%d')}
**From:** {plan_file}
""")
            print(f"‚úÖ Created: .czarina/README.md")

            # Update .gitignore
            gitignore = current_dir / ".gitignore"
            gitignore_content = ""
            if gitignore.exists():
                gitignore_content = gitignore.read_text()

            if ".czarina/status/" not in gitignore_content:
                with open(gitignore, "a") as f:
                    if gitignore_content and not gitignore_content.endswith("\n"):
                        f.write("\n")
                    f.write("\n# Czarina orchestration\n")
                    f.write(".czarina/status/\n")
                    f.write(".czarina/worktrees/\n")
                print(f"‚úÖ Updated: .gitignore")

            # Copy branch loader script
            loader_template = orchestrator_dir / "czarina-core" / "templates" / "embedded-orchestration" / "load-worker-by-branch.sh"
            loader_dest = czarina_dir / "load-worker-by-branch.sh"
            if loader_template.exists():
                import shutil
                shutil.copy(loader_template, loader_dest)
                loader_dest.chmod(0o755)
                print(f"‚úÖ Created: .czarina/load-worker-by-branch.sh")

            # Initialize git branches
            print()
            print("üåø Initializing git branches...")
            init_branches_script = orchestrator_dir / "czarina-core" / "init-embedded-branches.sh"
            if init_branches_script.exists() and (current_dir / ".git").exists():
                result = subprocess.run(
                    ["bash", str(init_branches_script), str(current_dir)],
                    input="n\n",  # Auto-answer "no" to pull prompt
                    text=True,
                    capture_output=True
                )
                if result.returncode == 0:
                    print(f"‚úÖ Git branches initialized")
                else:
                    print(f"‚ö†Ô∏è  Branch initialization failed (may need manual setup)")
                    print(f"   Run: ./czarina-core/init-embedded-branches.sh .")
            else:
                if not (current_dir / ".git").exists():
                    print(f"‚ö†Ô∏è  Not a git repository - skipping branch initialization")
                    print(f"   Initialize git first: git init && git add . && git commit -m 'Initial commit'")
                else:
                    print(f"‚ö†Ô∏è  Branch init script not found")

            print()
            print("=" * 60)
            print("‚úÖ PROJECT INITIALIZED")
            print("=" * 60)
            print()
            print(f"üìÅ Location: {current_dir}")
            print(f"üìã Project: {project_name}")
            print(f"üë∑ Workers: {len(config['workers'])}")
            print(f"üì¶ Versions: {len(config['version_plan'])}")
            print()
            print("üìù Next steps:")
            print("  1. Review .czarina/config.json")
            print("  2. Review .czarina/workers/*.md")
            print("  3. (Optional) Setup SessionStart hook in .claude/settings.local.json:")
            print("     See: docs/BRANCH_BASED_WORKER_LOADING.md")
            print("  4. git add .czarina/")
            print("  5. git commit -m 'Add Czarina orchestration'")
            print("  6. Workers: git checkout <branch> && start your agent")
            print("  7. (Optional) czarina daemon start")
            print()

        else:
            print()
            print("üí° To initialize project with this analysis:")
            print(f"   czarina analyze {plan_file} --init")
            print()
            print("Or save analysis for later:")
            print(f"   czarina analyze {plan_file} --output analysis.json")
            print()

    except Exception as e:
        print(f"‚ùå Analysis failed: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

    print("=" * 60)


def show_usage():
    """Show usage information"""
    print(__doc__)
    print("\nExamples:")
    print("  # Interactive analysis (works with Claude Code, Cursor, any agent!)")
    print("  czarina analyze implementation-plan.md --interactive --init")
    print("")
    print("  # Automated analysis (requires Anthropic API key)")
    print("  czarina analyze implementation-plan.md --init")
    print("")
    print("  # Analyze and save to file (no init)")
    print("  czarina analyze implementation-plan.md --output analysis.json")
    print("")
    print("  # Manual initialization")
    print("  cd ~/my-project && czarina init")
    print("")
    print("  # Launch from project directory")
    print("  cd ~/my-project && czarina launch")
    print("")
    print("  # Launch from anywhere by name")
    print("  czarina launch my-project")
    print("")
    print("  # Daemon and patterns")
    print("  czarina daemon start")
    print("  czarina patterns update")
    print("  czarina list")


def main():
    if len(sys.argv) < 2:
        show_usage()
        sys.exit(1)

    command = sys.argv[1]

    if command == "analyze":
        if len(sys.argv) < 3:
            print("‚ùå Usage: czarina analyze <plan-file> [--output file.json] [--init] [--interactive]")
            sys.exit(1)
        plan_file = sys.argv[2]
        output_file = None
        auto_init = False
        interactive = False
        # Parse optional flags
        for i in range(3, len(sys.argv)):
            if sys.argv[i] == "--output" and i + 1 < len(sys.argv):
                output_file = sys.argv[i + 1]
            elif sys.argv[i] == "--init":
                auto_init = True
            elif sys.argv[i] == "--interactive":
                interactive = True
        cmd_analyze(plan_file, output_file, auto_init, interactive)
    elif command == "init":
        # Check for --from-config and --force flags
        from_config = None
        project_name = None
        force = False

        i = 2
        while i < len(sys.argv):
            arg = sys.argv[i]
            if arg == "--from-config":
                if i + 1 < len(sys.argv):
                    from_config = sys.argv[i + 1]
                    i += 2
                else:
                    print("‚ùå --from-config requires a file path")
                    sys.exit(1)
            elif arg == "--force":
                force = True
                i += 1
            elif not arg.startswith("--"):
                project_name = arg
                i += 1
            else:
                i += 1

        cmd_init(project_name, from_config, force)
    elif command == "list":
        cmd_list()
    elif command == "launch":
        project_name = sys.argv[2] if len(sys.argv) > 2 else None
        cmd_launch(project_name)
    elif command == "status":
        project_name = sys.argv[2] if len(sys.argv) > 2 else None
        cmd_status(project_name)
    elif command == "dashboard":
        project_name = sys.argv[2] if len(sys.argv) > 2 else None
        cmd_dashboard(project_name)
    elif command == "phase":
        if len(sys.argv) < 3:
            print("‚ùå Usage: czarina phase <close> [project]")
            sys.exit(1)
        phase_cmd = sys.argv[2]
        if phase_cmd == "close":
            project_name = sys.argv[3] if len(sys.argv) > 3 else None
            cmd_phase_close(project_name)
        else:
            print(f"‚ùå Unknown phase command: {phase_cmd}")
            print("   Available: close")
            sys.exit(1)
    elif command == "closeout":
        project_name = sys.argv[2] if len(sys.argv) > 2 else None
        cmd_closeout(project_name)
    elif command == "daemon":
        if len(sys.argv) < 3:
            print("‚ùå Usage: czarina daemon <start|stop|logs|status> [project]")
            sys.exit(1)
        subcommand = sys.argv[2]
        project_name = sys.argv[3] if len(sys.argv) > 3 else None
        if subcommand == "start":
            cmd_daemon_start(project_name)
        elif subcommand == "stop":
            cmd_daemon_stop(project_name)
        elif subcommand == "logs":
            cmd_daemon_logs(project_name)
        elif subcommand == "status":
            cmd_daemon_status(project_name)
        else:
            print(f"‚ùå Unknown daemon subcommand: {subcommand}")
            print("   Valid: start, stop, logs, status")
            sys.exit(1)
    elif command == "patterns":
        if len(sys.argv) < 3:
            print("‚ùå Usage: czarina patterns <update|version|pending|contribute>")
            sys.exit(1)
        subcommand = sys.argv[2]
        if subcommand == "update":
            cmd_patterns_update()
        elif subcommand == "version":
            cmd_patterns_version()
        elif subcommand == "pending":
            cmd_patterns_pending()
        elif subcommand == "contribute":
            cmd_patterns_contribute()
        else:
            print(f"‚ùå Unknown patterns subcommand: {subcommand}")
            print("   Valid: update, version, pending, contribute")
            sys.exit(1)
    elif command in ["version", "-v", "--version"]:
        print(f"Czarina v{CZARINA_VERSION}")
        print("Multi-Agent Orchestration CLI")
        print()
        print("Repository: https://github.com/apathy-ca/czarina")
        print("Documentation: https://github.com/apathy-ca/czarina/tree/main/docs")
    elif command in ["-h", "--help", "help"]:
        show_usage()
    else:
        print(f"‚ùå Unknown command: {command}")
        show_usage()
        sys.exit(1)


if __name__ == "__main__":
    main()
